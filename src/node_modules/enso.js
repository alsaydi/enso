
with (global) {

  fs = require("fs");
    
  makeProxy = function(obj) {
    var proxy = null;
    var handler = {
      get : function (proxy, prop) {
         var x = obj[prop];
        if (x) {
         return x;
        } else {
         return function() { return obj.GET(prop); }
        }
      },
      set : function(proxy, name, val) {
        return obj.set(name, val);
      },
      keys : function() {
        return handler.GET("keys");
      }};
    proxy = Proxy.create(handler);
    return proxy;
  }

  makeArrayProxy = function(obj) {
    var proxy = null;
    var handler = {
      get : function (proxy, prop) {
         var x = obj[prop];
         return x ? x : obj.GET(prop);
      },
      set : function(proxy, name, val) {
        return obj.set(name, val);
      },
      keys : function() {
        return obj.keys;
      }};
    proxy = Proxy.create(handler);
    return proxy;
  }

  /*
  ProxyMixin = function(klass) {
    return function() {
      this.$ = {};
      return ProxyWrapper(klass.apply(this, arguments));
    }}
  */
  
  str = function() {
   return  Array.prototype.slice.call(arguments).join("");
    }
    
  puts = function(obj) {
    console.log("" + obj);
  }
  
  EnsoHash = function(init) {
    var data = new Object();
    this.has_key = function(key) { return data.hasOwnProperty(key); }
    this.GET = function(key) { return data[key]; }
  }
  
  System = {
    readJSON: function(path) {
      return JSON.parse(fs.readFileSync(path));
    }
  }
  
  closure = function(obj, fun) {
    return function () { 
       return fun.apply(obj, arguments);
     }
  }
  
  Object.prototype.has_key = Object.prototype.hasOwnProperty
  Array.prototype.each = Array.prototype.forEach

  Object.prototype.find = function(pred) { for (i in this) if (pred(a = this[i])) return a; }
  Object.prototype.is_a = function(type) { return this instanceof type; }
  Object.prototype.define_singleton_value = function(name, val) { this[name] = function() { return val;} }
  Object.prototype.define_singleton_method = function(name, val) { this[name] = val }
  String.prototype.to_s = function() { return this }
  Object.prototype.to_s = function() { return "" + this }
  raise = function(msg) { throw msg }
  Object.prototype.GET = function(k) { return this[k] }

  EnsoObject = { new: function() { return {} } };
  
  MakeClass = function(base, proto) {
      // base is the *class* object of the base class
      // proto is the record containing fields for this object
      //    which can contain a "_class_" field to specify its class data
      if (!proto) {
        proto = base;
        base = EnsoObject;
      }
      // create a class structure if there isn't one (for example, when inheriting Array)
      if (typeof base === "function") {
        base = { new: base };
      }

      // get the prototype of the base constructor function      
      var parent_proto = base.new.prototype;
      // connect this methods bindings to inherit the parent's methods 
      proto.__proto__ = parent_proto;
      // make sure there is a class object 
      proto._class_ = proto._class_ || {};
      // connect this object's class data to the base class data 
      proto._class_.__proto__ = base;
      // make sure there is an initializer function
      proto.initialize = proto.initialize || function() {
          if (parent_proto.hasOwnProperty("initialize")) {
              parent_proto.initialize.apply(this, arguments);
          }
      };

      // create the constructor function      
      var constructor = function() {
         var obj = Object.create(proto);
         obj.$ = {};
         proto.initialize.apply(obj, arguments);
         return obj;
      }
      // set its prototype, even thought it is not actually used view "new"
      // it is accessed above
      constructor.prototype = proto;
      // fill in the "new" function of the class
      proto._class_.new = constructor;
      // return the new class
      return proto._class_;
  }


}
