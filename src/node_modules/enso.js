
with (global) {

  fs = require("fs");
    
  MakeProxy = function(obj) {
    var proxy = null;
    var handler = {
      get : function (proxy, prop) {
         var x = obj[prop];
        if (x) {
         return x;
        } else {
         return function() { return obj._get(prop); }
        }
      },
      set : function(proxy, name, val) {
        return obj.set(name, val);
      },
      keys : function() {
        return handler._get("keys");
      }};
    proxy = Proxy.create(handler);
    return proxy;
  }

  makeArrayProxy = function(obj) {
    var proxy = null;
    var handler = {
      get : function (proxy, prop) {
         var x = obj[prop];
         return x ? x : obj._get(prop);
      },
      set : function(proxy, name, val) {
        return obj.set(name, val);
      },
      keys : function() {
        return obj.keys;
      }};
    proxy = Proxy.create(handler);
    return proxy;
  }

  /*
  ProxyMixin = function(klass) {
    return function() {
      this.$ = {};
      return ProxyWrapper(klass.apply(this, arguments));
    }}
  */
  
  S = function() {
   return  Array.prototype.slice.call(arguments).join("");
    }
    
  puts = function(obj) {
    console.log("" + obj);
  }
  
  EnsoHash = function(init) {
    var data = new Object();
    this.has_key_P = function(key) { return data.hasOwnProperty(key); }
    this._get = function(key) { return data[key]; }
  }
  
  System = {
    readJSON: function(path) {
      return JSON.parse(fs.readFileSync(path));
    }
  }
  
  closure = function(obj, fun) {
    return function () { 
       return fun.apply(obj, arguments);
     }
  }
  
  Object.prototype.has_key_P = Object.prototype.hasOwnProperty
  Array.prototype.each = Array.prototype.forEach

  Object.prototype.find = function(pred) { for (i in this) if (pred(a = this[i])) return a; }
  Object.prototype.is_a_P = function(type) { return this instanceof type; }
  Object.prototype.define_singleton_value = function(name, val) { this[name] = function() { return val;} }
  Object.prototype.define_singleton_method = function(name, val) { this[name] = val }
  String.prototype.to_s = function() { return this }
  Object.prototype.to_s = function() { return "" + this }
  raise = function(msg) { throw msg }
  Object.prototype._get = function(k) { return this[k] }

  EnsoBaseClass = {
    finalize_object$: function(x) { return x },
    new: function() {}
  }

  MakeClass = function(base_class, instance_spec) {
      // NewClass = MakeClass(ParentClass, { 
      //    _class_: { 
      //         class_var1: init-value,            // @@var
      //         class_method: function(...) {...}  // def self.class_method(...) ...
      //         // the "new" method gets added here
      //     },
      //     initialize: function(..) {             // def intialize(..) 
      //        this.$.instance_var = init-value;   //    @instance_vaf = ...
      //     },
      //     instance_method: function(a, b) {    // def instance_method(a, b, *args)
      //        var self = this;                  // default preamble
      //        args = get_rest_arguments(arguments, 2)  // autogenerated call to set up rest args
      //        self.$.var                          // @var
      //        self._class_.var                    // @@var
      //        self.super$.foo.apply(self, arguments);    // super
      //        self.super$.foo.call(self, arg1, arg2...); // super(arg1, arg2)  # in foo method
      //        o.foo(a,b,*c)                       // o.foo.call_method(a, b, c)  # where call_method is in the library
      //     }
      //  }
      // return value: the value of _class_ is the return value (or a synthetic new _class_ is added for you)
          
      // base_class is the *class* object of the base class
      // instance_spec is the record containing fields for this object
      //    which can contain a "_class_" field to specify its class data
      if (!instance_spec) {
        instance_spec = base_class;
        base_class = EnsoBaseClass;
      }
      // create a class structure if there isn't one (for example, when inheriting Array)
      if (typeof base_class === "function") {
        var temp = new Object(EnsoBaseClass);
        temp.new = base_class;
        base_class = temp;
      }

      // get the prototype of the base constructor function      
      var parent_instance_proto = base_class.new.prototype;
      // connect this instance_spec bindings to inherit the parent's instance_spec 
      instance_spec.__proto__ = parent_instance_proto;
      // make sure there is a class object 
      instance_spec._class_ = instance_spec.hasOwnProperty("_class_") ? instance_spec._class_ : Object.create({});
      // connect this object's class data to the base class data 
      instance_spec._class_.__proto__ = base_class;
      // make sure there is an initializer function
      instance_spec.initialize = instance_spec.initialize || function() {
          if (parent_instance_proto.hasOwnProperty("initialize")) {
              parent_instance_proto.initialize.apply(this, arguments);
          }
      };

      // create the constructor function      
      var constructor = function() {
         var obj = Object.create(instance_spec);
         obj.$ = {};
         obj.super$ = parent_instance_proto;
         instance_spec.initialize.apply(obj, arguments);
         return instance_spec._class_.finalize_object$(obj);
      }
      // set its prototype, even thought it is not actually used view "new"
      // it is accessed above
      constructor.prototype = instance_spec;
      // fill in the "new" function of the class
      instance_spec._class_.new = constructor;
      // return the new class
      return instance_spec._class_;
  }  

  EnsoProxyObject = MakeClass({
    _class_: {
      finalize_object$: MakeProxy
    }
  });
  

}
