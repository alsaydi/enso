
import expr.schema

primitive str 
primitive int 
primitive bool 

class Grammar 
  start: Rule 
  rules! Rule* 

class Pattern
  prev: Pattern?
  nxt: Pattern?

class End < Pattern

class EpsilonEnd < End

// Pattern is needed because Ends refer to it via nxt
class Rule < Pattern
  name# str 
  grammar: Grammar / rules 
  arg! Pattern?   // optional because of abstract rules
  original! Pattern?
 
class Alt < Pattern 
  alts! Pattern+ 

class Sequence < Pattern 
  elements! Pattern* 
 
class Create < Pattern 
  name: str 
  arg! Pattern
 
class Field < Pattern 
  name: str 
  arg! Pattern 
 
class Terminal < Pattern

class Value < Terminal
  kind: str 
 
class Ref < Terminal
   path! Expr

class Lit < Terminal
  value: str

class Layout < Terminal
 
class Call < Pattern 
  rule: Rule 

 
class Regular < Pattern 
  arg! Pattern 
  optional: bool 
  many: bool 
  sep! Pattern ? 

class NoSpace < Pattern

class Break < Pattern
  lines: int

class Indent < Pattern
  indent: int
 
class Epsilon < Pattern

class Code < Epsilon
  expr! Expr
 
class Base
  starts: int
  ends: int
  type: Pattern
  origin! Location?

class Node < Base
  kids: Pack*

class Leaf < Base
  value: str
  ws: str

class Pack
  parent: Node / kids
  type: Pattern
  pivot: int
  left: Base?
  right: Base

class GSS
  item! Pattern
  pos: int
  edges: Edge*

class Edge
  sppf: Base
  target: GSS

class Location
  path: str
  offset: int
  size: int
  start_line: int
  start_column: int
  end_line: int
  end_column: int
