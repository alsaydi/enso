
class Grammar
  @first: First = First { entries: rules.entry }
end

class Rule
  @nullable: bool = arg.nullable
  @first: Token* = arg.first
  @enty: Entry = Entry {name: name, first}
end

class Expression
  @nullable: bool = false
end

class Alt
  @nullable: bool = any(alts.nullable) 
  @first: Token* = alts.first // implicit big-union
end

class Sequence
  @nullable: bool = all(elements.nullable)
  @first: Token* = for e <- elements do
                     e.first;
                     if !e.nullable then
                       break
                     end
                   end
end

class Field
  @nullable: bool = arg.nullable
  @first: Token* = arg.first
end

class Create
  @nullable: bool = arg.nullable
  @first: Token* = arg.first
end

class Call
  @nullable: bool = rule.nullable
  @first: Token* = rule.first
end

class Regular
  @nullable: bool = if optional then true else arg.nullable end
  @first: Token* = arg.first
end

class Value < Expression 
  @first: Token* = { Token {type: kind} }
end 

class Ref < Expression 
  @first: Token* = { Token {type: "sym"} }
end 

class Lit < Expression 
  @first: Token* = { Token {type: "LIT:" + value} }
end 

