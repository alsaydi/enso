require "core/schema/code/many"
require "core/schema/code/dynamic"
require "core/system/utils/paths"
require "core/system/library/schema"
require "core/semantics/code/interpreter"
require "core/expr/code/impl"
require "core/expr/code/env"
require "core/expr/code/freevar"

module ManagedData
  class Factory

    attr_reader "schema"

    def initialize(schema)
      @schema = schema;
      @roots = [];
      self.__constructor(schema.types);
      @file_path = [];
    end

    def [](name)
      self.send(name);
    end

    def register(root)
      @roots.push(root);
    end

    def delete_in_place(obj)
      @roots.each do |root|
        root.__delete_obj(obj);
      end
    end

    attr_accessor "file_path"

    def __constructor(klasses)
      klasses.each do |klass|
        self.define_singleton_method(klass.name) do |*args|
          MObject.new(klass, self, *args);
        end
      end
    end
  end

  class MObject < EnsoProxyObject
    @@_id = 0

    attr_accessor "_origin"

    attr_accessor "__shell"

    attr_reader "_id"

    attr_reader "factory"

    attr_reader "schema_class"

    attr_accessor "extra_instance_data"

    def initialize(klass, factory, *args)
      @_id = @@_id = @@_id + 1;
      @schema_class = klass;
      @factory = factory;
      @hash = {};
      @listeners = {};
      @memo = {};
      self.__setup(klass.all_fields);
      self.__init(klass.fields, args);
      self.__install(klass.all_fields);
    end

    def _graph_id
      @factory;
    end

    def instance_of_P(sym)
      self.schema_class.name == sym.to_s;
    end

    def [](name)
      if name[- 1] == "?" then
        self.schema_class.name == name.slice(0, name.length - 1);
      else
        self.check_field(name, true);
        if self.computed_P(name) then
          self.send(name);
        else
          self.__get(name).get;
        end
      end
    end

    def []=(name, x)
      self.check_field(name, false);
      self.__get(name).set(x);
    end

    def delete_in_place
      self.factory.delete_in_place(self);
    end

    def __delete_obj(mobj)
      self.schema_class.fields.each do |fld|
        if fld.traversal then
          self.__get(fld.name).__delete_obj(mobj);
        end
      end
    end

    def dynamic_update
      @dyn = @dyn || DynamicUpdateProxy.new(self);
    end

    def add_listener(name, &block)
      local :listeners
      listeners = @listeners[name];
      if ! listeners then
        listeners = @listeners[name] = [];
      end
      listeners.push(block);
    end

    def notify(name, val)
      if @listeners[name] then
        @listeners[name].each do |blk|
          blk.call(val);
        end
      end
    end

    def _origin_of(name)
      self.__get(name)._origin;
    end

    def _set_origin_of(name, org)
      self.__get(name)._origin = org;
    end

    def _path_of(name)
      self._path.field(name);
    end

    def _path
      if self.__shell then
        self.__shell._path(self);
      else
        Paths.new;
      end
    end

    def _clone
      local :r
      r = MObject.new(@schema_class, @factory);
      self.schema_class.fields.each do |field|
        if field.many then
          self[field.name].each do |o|
            r[field.name].push(o);
          end
        else
          r[field.name] = self[field.name];
        end
      end
      r;
    end

    def __get(name)
      @hash[name];
    end

    def __set(name, fld)
      @hash[name] = fld;
    end

    def eql_P(o)
      self == o;
    end

    def equals(o)
      (o && o.is_a_P(MObject)) && self._id == o._id;
    end

    def hash
      self._id;
    end

    def to_s
      local :k
      k = Schema.class_key(self.schema_class);
      if k then
        S("<<", self.schema_class.name, " ", self._id, " '", self[k.name], "'>>");
      else
        S("<<", self.schema_class.name, " ", self._id, ">>");
      end
    end

    def finalize
      self.factory.register(self);
      self;
    end

    def check_field(name, can_be_computed)
      if ! @hash.include_P(name) then
        self.raise(S("Non-existing field '", name, "' for ", self));
      end
      if ! can_be_computed && self.computed_P(name) then
        self.raise(S("Cannot assign to computed field '", name, "'"));
      end
    end

    def computed_P(name)
      self.__get(name) == "computed";
    end

    def __setup(fields)
      local :klass , :key , :f
      fields.each do |fld|
        klass = self;
        f = if fld.computed then
          "computed";
        elsif fld.type.Primitive_P then
          ManagedData.Prim.new(klass, fld);
        elsif ! fld.many then
          ManagedData.Ref.new(klass, fld);
        elsif (
          key = Schema.class_key(fld.type);
        ) then
          ManagedData.Set.new(klass, fld, key);
        else
          ManagedData.List.new(klass, fld);
        end
        self.__set(fld.name, f);
      end
    end

    def __init(fields, args)
      fields.each_with_index do |fld, i|
        if i < args.length then
          self.__get(fld.name).init(args[i]);
        end
      end
    end

    def __install(fields)
      local :c , :base
      fields.each do |fld|
        if fld.computed then
          if fld.computed.EList_P && (
            c = fld.owner.supers.find do |c|
              c.all_fields[fld.name];
            end
          ) then
            base = c.all_fields[fld.name];
            if base.inverse then
              fld.computed.elems.each do |var_V|
                if ! var_V.EVar_P then
                  self.raise(S("Field override ", fld.name, " includes non-var ", var_V));
                end
                self.__get(var_V.name)._set_inverse = base.inverse;
              end
            end
          end
          self.__computed(fld);
        else
          self.__setter(fld.name);
          self.__getter(fld.name);
        end
      end
    end

    def __computed(fld)
      local :name , :exp , :fvInterp , :commInterp , :fvs , :val
      name = fld.name;
      exp = fld.computed;
      fvInterp = Interpreter(FreeVarExpr);
      commInterp = Interpreter(EvalCommand);
      self.define_singleton_method(name) do
        if @memo[name] == nil then
          fvs = fvInterp.depends(exp, {});
          fvs.each do |fv|
            if fv.object then
              fv.object.add_listener(fv.index) do
                @memo[name] = nil;
              end
            end
          end
          val = commInterp.eval(exp, {});
          @memo[name] = val;
        end
        @memo[name];
      end
    end

    def __setter(name)
    end

    def __getter(name)
    end
  end

  class Field

    attr_accessor "_origin"

    def set__set_inverse(inv)
      if @inverse then
        self.raise(S("Overiding inverse of field '", inv.owner.name, ".", self.invk.name, "'"));
      end
      @inverse = inv;
    end

    def initialize(owner, field)
      @owner = owner;
      @field = field;
      if field then
        @inverse = field.inverse;
      end
    end

    def __delete_obj(mobj)
    end

    def to_s
      S(".", @field.name, " = ", @value);
    end
  end

  class Single < Field

    def initialize(owner, field)
      super(owner, field);
      @value = self.default_V;
    end

    def set(value)
      self.check(value);
      @value = value;
      @owner.notify(@field.name, value);
    end

    def get
      @value;
    end

    def init(value)
      self.set(value);
    end

    def default
      nil;
    end
  end

  class Prim < Single

    def check(value)
      local :ok
      if ! @field.optional || value then
        ok = if @field.type.name == "str" then
          value.is_a_P(String);
        elsif @field.type.name == "int" then
          value.is_a_P(Integer);
        elsif @field.type.name == "bool" then
          value.is_a_P(TrueClass) || value.is_a_P(FalseClass);
        elsif @field.type.name == "real" then
          value.is_a_P(Numeric);
        elsif @field.type.name == "datetime" then
          value.is_a_P(DateTime);
        elsif @field.type.name == "atom" then
          ((value.is_a_P(Numeric) || value.is_a_P(String)) || value.is_a_P(TrueClass)) || value.is_a_P(FalseClass);
        end
        if ! ok then
          self.raise(S("Invalid value for ", @field.type.name, ": ", value));
        end
      end
    end

    def default
      if ! @field.optional then
        if @field.type.name == "str" then
          "";
        elsif @field.type.name == "int" then
          0;
        elsif @field.type.name == "bool" then
          false;
        elsif @field.type.name == "real" then
          0.0;
        elsif @field.type.name == "datetime" then
          DateTime.now;
        elsif @field.type.name == "atom" then
          nil;
        else
          self.raise(S("Unknown primitive type: ", @field.type.name));
        end
      end
    end
  end

  module RefHelpers

    def notify(old, new_V)
      if old != new_V then
        @owner.notify(@field.name, new_V);
        if @inverse then
          if @inverse.many then
            if old then
              old.__get(@inverse.name).__delete(@owner);
            end
            if new_V then
              new_V.__get(@inverse.name).__insert(@owner);
            end
          else
            if old then
              old.__get(@inverse.name).__set(nil);
            end
            if new_V then
              new_V.__get(@inverse.name).__set(@owner);
            end
          end
        end
      end
    end

    def check(mobj)
      if mobj || ! @field.optional then
        if mobj.nil_P then
          self.raise(S("Cannot assign nil to non-optional field ", @field.name));
        end
        if ! Schema.subclass_P(mobj.schema_class, @field.type) then
          self.raise(S("Invalid value for '", @field.owner.name, ".", @field.name, "': ", mobj, " : ", mobj.schema_class.name));
        end
        if mobj._graph_id != @owner._graph_id then
          self.raise(S("Inserting object ", mobj, " into the wrong model"));
        end
      end
    end
  end

  class Ref < Single

    include RefHelpers

    def set(value)
      self.check(value);
      self.notify(self.get, value);
      self.__set(value);
    end

    def __set(value)
      if @field.traversal then
        if value then
          value.__shell = self;
        end
        if self.get && ! value then
          self.get.__shell = nil;
        end
      end
      @value = value;
    end

    def _path(_)
      @owner._path.field(@field.name);
    end

    def __delete_obj(mobj)
      if self.get == mobj then
        self.set(nil);
      end
    end
  end

  class Many < Field

    include RefHelpers

    include Enumerable

    def get
      self;
    end

    def set
      self.raise(S("Cannot assign to many-valued field ", @field.name));
    end

    def init(values)
      values.each do |value|
        self.push(value);
      end
    end

    def __value
      @value;
    end

    def [](key)
      self.__value[key];
    end

    def empty_P
      self.__value.empty_P;
    end

    def length
      self.__value.length;
    end

    def to_s
      self.__value.to_s;
    end

    def clear
      self.__value.clear;
    end

    def connected_P
      @owner;
    end

    def has_key_P(key)
      self.keys.include_P(key);
    end

    def check(mobj)
      if self.connected_P then
        super(mobj);
      end
    end

    def notify(old, new_V)
      if self.connected_P then
        super(old, new_V);
      end
    end

    def __delete_obj(mobj)
      if self.values.include_P(mobj) then
        self.delete(mobj);
      end
    end

    def connect(mobj, shell)
      if self.connected_P && @field.traversal then
        mobj.__shell = shell;
      end
    end
  end

  class Set < Many

    include SetUtils

    def initialize(owner, field, key)
      super(owner, field);
      @value = {};
      @key = key;
    end

    def each(&block)
      self.__value.each_value(&block);
    end

    def each_pair(&block)
      self.__value.each_pair(&block);
    end

    def find_first_pair(&block)
      self.__value.find_first_pair(&block);
    end

    def values
      self.__value.values;
    end

    def keys
      self.__value.keys;
    end

    def _recompute_hash_in_place
      local :nval
      nval = {};
      @value.each do |k, v|
        nval[v[@key.name]] = v;
      end
      @value = nval;
      self;
    end

    def push(mobj)
      local :key
      self.check(mobj);
      key = mobj[@key.name];
      if ! key then
        self.raise(S("Nil key when adding ", mobj, " to ", self));
      end
      if @value[key] != mobj then
        if @value[key] then
          self.delete(@value[key]);
        end
        self.notify(@value[key], mobj);
        self.__insert(mobj);
      end
      self;
    end

    def []=(index, mobj)
      self.push(mobj);
    end

    def delete(mobj)
      local :key
      key = mobj[@key.name];
      if @value.has_key_P(key) then
        self.notify(@value[key], nil);
        self.__delete(mobj);
      end
    end

    def _path(mobj)
      @owner._path.field(@field.name).key(mobj[@key.name]);
    end

    def __insert(mobj)
      self.connect(mobj, self);
      @value[mobj[@key.name]] = mobj;
    end

    def __delete(mobj)
      local :deleted
      deleted = @value.delete(mobj[@key.name]);
      self.connect(deleted, nil);
      deleted;
    end
  end

  class List < Many

    include ListUtils

    def initialize(owner, field)
      super(owner, field);
      @value = [];
    end

    def [](key)
      self.__value[key.to_i];
    end

    def each(&block)
      self.__value.each(&block);
    end

    def each_pair(&block)
      self.__value.each_with_index do |item, i|
        block.call(i, item);
      end
    end

    def values
      self.__value;
    end

    def keys
      Array.new(self.length) do |i|
        i;
      end
    end

    def push(mobj)
      if ! mobj then
        self.raise("Cannot insert nil into list");
      end
      self.check(mobj);
      self.notify(nil, mobj);
      self.__insert(mobj);
      self;
    end

    def []=(index, mobj)
      local :old
      if ! mobj then
        self.raise("Cannot insert nil into list");
      end
      old = self.__value[index.to_i];
      if old != mobj then
        self.check(mobj);
        self.notify(nil, mobj);
        self.__value[index.to_i] = mobj;
        if old then
          self.notify(old, nil);
        end
      end
      self;
    end

    def delete(mobj)
      local :deleted
      deleted = self.__delete(mobj);
      if deleted then
        self.notify(deleted, nil);
      end
      deleted;
    end

    def insert(index, mobj)
      if ! mobj then
        self.raise("Cannot insert nil into list");
      end
      self.check(mobj);
      self.notify(nil, mobj);
      @value.insert(index.to_i, mobj);
      self;
    end

    def _path(mobj)
      @owner._path.field(@field.name).index(@value.index(mobj));
    end

    def __insert(mobj)
      self.connect(mobj, self);
      @value.push(mobj);
    end

    def __delete(mobj)
      local :deleted
      deleted = @value.delete(mobj);
      self.connect(deleted, nil);
      deleted;
    end
  end

  def self.new(schema)
    Factory.new(schema);
  end
end
