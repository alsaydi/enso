require "enso"
require "core/schema/code/many"
require "core/schema/code/dynamic"
require "core/system/utils/paths"
require "core/system/library/schema"
require "core/semantics/code/interpreter"
require "core/expr/code/impl"
require "core/expr/code/env"
require "core/expr/code/freevar"

module ManagedData
  class Factory
    attr_reader "schema"
    def initialize(schema)
      @schema = schema;
      @roots = [];
      __constructor(schema.types);
      @file_path = [];
    end
    def [](name)
      send(name);
    end
    def register(root)
      @roots.push(root);
    end
    def delete_in_place(obj)
      @roots.each do |root|
        root.__delete_obj(obj);
      end
    end
    attr_accessor "file_path"
    def __constructor(klasses)
      klasses.each do |klass|
        define_singleton_method(klass.name) do |*args|
          MObject.new(klass, self, *args);
        end
      end
    end
  end

  class MObject
    @@_id = 0
    attr_accessor "_origin"
    attr_accessor "__shell"
    attr_reader "_id"
    attr_reader "factory"
    attr_reader "schema_class"
    def initialize(klass, factory, *args)
      @_id = @@_id += 1;
      @schema_class = klass;
      @factory = factory;
      @hash = {};
      @listeners = {};
      @memo = {};
      __setup(klass.all_fields);
      __init(klass.fields, args);
      __install(klass.all_fields);
    end
    def method_missing(sym, *args, &block)
      if sym[- 1] == "?" then
        schema_class.name == sym.slice(0, sym.length - 1);
      else
        super(sym, *args, &block);
      end
    end
    def _graph_id
      @factory;
    end
    def instance_of_p(sym)
      schema_class.name == sym.to_s;
    end
    def [](name)
      check_field(name, true);
      if computed_p(name) then
        send(name);
      else
        __get(name).get;
      end
    end
    def []=(name, x)
      check_field(name, false);
      __get(name).set(x);
    end
    def delete_in_place
      factory.delete_in_place(self);
    end
    def __delete_obj(mobj)
      schema_class.fields.each do |fld|
        if fld.traversal then
          __get(fld.name).__delete_obj(mobj);
        end
      end
    end
    def dynamic_update
      @dyn ||= DynamicUpdateProxy.new(self);
    end
    def add_listener(name, &block)
      (
        @listeners[name] ||= [];
      ).push(block);
    end
    def notify(name, val)
      if @listeners[name] then
        @listeners[name].each do |blk|
          blk.call(val);
        end
      end
    end
    def _origin_of(name)
      __get(name)._origin;
    end
    def _set_origin_of(name, org)
      __get(name)._origin = org;
    end
    def _path_of(name)
      _path.field(name);
    end
    def _path
      if __shell then
        __shell._path(self);
      else
        Paths.new;
      end
    end
    def _clone
      r = MObject.new(@schema_class, @factory);
      schema_class.fields.each do |field|
        if field.many then
          self[field.name].each do |o|
            r[field.name].push(o);
          end
        else
          r[field.name] = self[field.name];
        end
      end
      r;
    end
    def __get(name)
      @hash[name];
    end
    def __set(name, fld)
      @hash[name] = fld;
    end
    def eql_p(o)
      self == o;
    end
    def equals(o)
      (o && o.is_a_p(MObject)) && _id == o._id;
    end
    def hash
      _id;
    end
    def to_s
      k = ClassKey(schema_class);
      if k then
        str("<<", schema_class.name, " ", _id, " '", self[k.name], "'>>");
      else
        str("<<", schema_class.name, " ", _id, ">>");
      end
    end
    def finalize
      factory.register(self);
      self;
    end
    def check_field(name, can_be_computed)
      if ! @hash.include_p(name) then
        raise(str("Non-existing field '", name, "' for ", self));
      end
      if ! can_be_computed && computed_p(name) then
        raise(str("Cannot assign to computed field '", name, "'"));
      end
    end
    def computed_p(name)
      __get(name) == "computed";
    end
    def __setup(fields)
      fields.each do |fld|
        klass = self;
        f = if fld.computed then
          "computed";
        elsif fld.type.Primitive_p then
          ManagedData.Prim.new(klass, fld);
        elsif ! fld.many then
          ManagedData.Ref.new(klass, fld);
        elsif (
          key = ClassKey(fld.type);
        ) then
          ManagedData.Set.new(klass, fld, key);
        else
          ManagedData.List.new(klass, fld);
        end
        __set(fld.name, f);
      end
    end
    def __init(fields, args)
      fields.each_with_index do |fld, i|
        if i < args.length then
          __get(fld.name).init(args[i]);
        end
      end
    end
    def __install(fields)
      fields.each do |fld|
        if fld.computed then
          if fld.computed.EList_p && (
            c = fld.owner.supers.find do |c|
              c.all_fields[fld.name];
            end
          ) then
            base = c.all_fields[fld.name];
            if base.inverse then
              fld.computed.elems.each do |var|
                if ! var.EVar_p then
                  raise(str("Field override ", fld.name, " includes non-var ", var));
                end
                __get(var.name)._set_inverse = base.inverse;
              end
            end
          end
          __computed(fld);
        else
          __setter(fld.name);
          __getter(fld.name);
        end
      end
    end
    def __computed(fld)
      name = fld.name;
      exp = fld.computed;
      fvInterp = Interpreter(FreeVarExpr);
      commInterp = Interpreter(EvalCommand);
      define_singleton_method(name) do
        if @memo[name] == nil then
          fvs = fvInterp.depends(exp, {});
          fvs.each do |fv|
            if fv.object then
              fv.object.add_listener(fv.index) do
                @memo[name] = nil;
              end
            end
          end
          val = commInterp.eval(exp, {});
          @memo[name] = val;
        end
        @memo[name];
      end
    end
    def __setter(name)
      define_singleton_method(str(name, "=")) do |arg|
        self[name] = arg;
      end
    end
    def __getter(name)
      define_singleton_method(name) do
        self[name];
      end
    end
  end

  class Field
    attr_accessor "_origin"
    def set__set_inverse(inv)
      if @inverse then
        raise(str("Overiding inverse of field '", inv.owner.name, ".", invk.name, "'"));
      end
      @inverse = inv;
    end
    def initialize(owner, field)
      @owner = owner;
      @field = field;
      if field then
        @inverse = field.inverse;
      end
    end
    def __delete_obj(mobj)
    end
    def to_s
      str(".", @field.name, " = ", @value);
    end
  end

  class Single < Field
    def initialize(owner, field)
      super(owner, field);
      @value = default;
    end
    def set(value)
      check(value);
      @value = value;
      @owner.notify(@field.name, value);
    end
    def get
      @value;
    end
    def init(value)
      set(value);
    end
    def default
      nil;
    end
  end

  class Prim < Single
    def check(value)
      if ! @field.optional || value then
        ok = if @field.type.name == "str" then
          value.is_a_p(String);
        elsif @field.type.name == "int" then
          value.is_a_p(Integer);
        elsif @field.type.name == "bool" then
          value.is_a_p(TrueClass) || value.is_a_p(FalseClass);
        elsif @field.type.name == "real" then
          value.is_a_p(Numeric);
        elsif @field.type.name == "datetime" then
          value.is_a_p(DateTime);
        elsif @field.type.name == "atom" then
          ((value.is_a_p(Numeric) || value.is_a_p(String)) || value.is_a_p(TrueClass)) || value.is_a_p(FalseClass);
        end
        if ! ok then
          raise(str("Invalid value for ", @field.type.name, ": ", value));
        end
      end
    end
    def default
      if ! @field.optional then
        if @field.type.name == "str" then
          "";
        elsif @field.type.name == "int" then
          0;
        elsif @field.type.name == "bool" then
          false;
        elsif @field.type.name == "real" then
          0.0;
        elsif @field.type.name == "datetime" then
          DateTime.now;
        elsif @field.type.name == "atom" then
          nil;
        else
          raise(str("Unknown primitive type: ", @field.type.name));
        end
      end
    end
  end

  module RefHelpers
    def notify(old, new)
      if old != new then
        @owner.notify(@field.name, new);
        if @inverse then
          if @inverse.many then
            if old then
              old.__get(@inverse.name).__delete(@owner);
            end
            if new then
              new.__get(@inverse.name).__insert(@owner);
            end
          else
            if old then
              old.__get(@inverse.name).__set(nil);
            end
            if new then
              new.__get(@inverse.name).__set(@owner);
            end
          end
        end
      end
    end
    def check(mobj)
      if mobj || ! @field.optional then
        if mobj.nil_p then
          raise(str("Cannot assign nil to non-optional field ", @field.name));
        end
        if ! Subclass_p(mobj.schema_class, @field.type) then
          raise(str("Invalid value for '", @field.owner.name, ".", @field.name, "': ", mobj, " : ", mobj.schema_class.name));
        end
        if mobj._graph_id != @owner._graph_id then
          raise(str("Inserting object ", mobj, " into the wrong model"));
        end
      end
    end
  end

  class Ref < Single
    include RefHelpers
    def set(value)
      check(value);
      notify(get, value);
      __set(value);
    end
    def __set(value)
      if @field.traversal then
        if value then
          value.__shell = self;
        end
        if get && ! value then
          get.__shell = nil;
        end
      end
      @value = value;
    end
    def _path(_)
      @owner._path.field(@field.name);
    end
    def __delete_obj(mobj)
      if get == mobj then
        set(nil);
      end
    end
  end

  class Many < Field
    include RefHelpers
    include Enumerable
    def get
      self;
    end
    def set
      raise(str("Cannot assign to many-valued field ", @field.name));
    end
    def init(values)
      values.each do |value|
        self.push(value);
      end
    end
    def __value
      @value;
    end
    def [](key)
      __value[key];
    end
    def empty_p
      __value.empty_p;
    end
    def length
      __value.length;
    end
    def to_s
      __value.to_s;
    end
    def clear
      __value.clear;
    end
    def connected_p
      @owner;
    end
    def has_key_p(key)
      keys.include_p(key);
    end
    def check(mobj)
      if connected_p then
        super(mobj);
      end
    end
    def notify(old, new)
      if connected_p then
        super(old, new);
      end
    end
    def __delete_obj(mobj)
      if values.include_p(mobj) then
        delete(mobj);
      end
    end
    def connect(mobj, shell)
      if connected_p && @field.traversal then
        mobj.__shell = shell;
      end
    end
  end

  class Set < Many
    include SetUtils
    def initialize(owner, field, key)
      super(owner, field);
      @value = {};
      @key = key;
    end
    def each(&block)
      __value.each_value(&block);
    end
    def each_pair(&block)
      __value.each_pair(&block);
    end
    def values
      __value.values;
    end
    def keys
      __value.keys;
    end
    def _recompute_hash_in_place
      nval = {};
      @value.each do |k, v|
        nval[v[@key.name]] = v;
      end
      @value = nval;
      self;
    end
    def push(mobj)
      check(mobj);
      key = mobj[@key.name];
      if ! key then
        raise(str("Nil key when adding ", mobj, " to ", self));
      end
      if @value[key] != mobj then
        if @value[key] then
          delete(@value[key]);
        end
        notify(@value[key], mobj);
        __insert(mobj);
      end
      self;
    end
    def []=(index, mobj)
      self.push(mobj);
    end
    def delete(mobj)
      key = mobj[@key.name];
      if @value.has_key_p(key) then
        notify(@value[key], nil);
        __delete(mobj);
      end
    end
    def _path(mobj)
      @owner._path.field(@field.name).key(mobj[@key.name]);
    end
    def __insert(mobj)
      connect(mobj, self);
      @value[mobj[@key.name]] = mobj;
    end
    def __delete(mobj)
      deleted = @value.delete(mobj[@key.name]);
      connect(deleted, nil);
      deleted;
    end
  end

  class List < Many
    include ListUtils
    def initialize(owner, field)
      super(owner, field);
      @value = [];
    end
    def [](key)
      __value[key.to_i];
    end
    def each(&block)
      __value.each(&block);
    end
    def each_pair(&block)
      __value.each_with_index do |item, i|
        block.call(i, item);
      end
    end
    def values
      __value;
    end
    def keys
      Array.new(length) do |i|
        i;
      end
    end
    def push(mobj)
      if ! mobj then
        raise("Cannot insert nil into list");
      end
      check(mobj);
      notify(nil, mobj);
      __insert(mobj);
      self;
    end
    def []=(index, mobj)
      if ! mobj then
        raise("Cannot insert nil into list");
      end
      check(mobj);
      notify(nil, mobj);
      old = __value[index.to_i];
      __value[index.to_i] = mobj;
      if old then
        notify(old, nil);
      end
      self;
    end
    def delete(mobj)
      deleted = __delete(mobj);
      if deleted then
        notify(deleted, nil);
      end
      deleted;
    end
    def insert(index, mobj)
      if ! mobj then
        raise("Cannot insert nil into list");
      end
      check(mobj);
      notify(nil, mobj);
      @value.insert(index.to_i, mobj);
      self;
    end
    def _path(mobj)
      @owner._path.field(@field.name).index(@value.index(mobj));
    end
    def __insert(mobj)
      connect(mobj, self);
      @value.push(mobj);
    end
    def __delete(mobj)
      deleted = @value.delete(mobj);
      connect(deleted, nil);
      deleted;
    end
  end
  def self.new(schema)
    Factory.new(schema);
  end
end
