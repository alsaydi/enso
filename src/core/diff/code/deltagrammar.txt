



Problem of distributing

class X
  y: Y*
  z: Z*


Grammar

 Foo ::= [X] Bar*

 Bar ::= y:Y
      |  z:Z

Adding an Y or a Z happens at the higher list

Statemachine delta

start (! X)

(+ state Bla
     enter X
     leave Y
     on "x" go Z )

(- Foo) // use key?

state Z
   (+ enter "sdsd")
   on "Bla" do (! "sdsad") go to F


ref_delta(x: X^) = Update(X^) where
Update(X^) ::= "<x>" ":" "..."
	    |  "(" "!" x: sym ")"

delta(X ::= A_1 | ... | A_n) = 
  D(X) ::= D(A1) | ... | D(A_n)

delta(X) ::= D(X)

delta([C] S_1 ... S_n) = 
  [D(C)]  D(S_1) ... D(S_n)

delta(f: E) = f: D(E)
where D(E) ::= ... is delta(E)

delta(E?) = D(E?)
where
  D(E?) ::= delete
          |  change(D(E))
	  |  "..."
where D(E) ::= ... is delta(E)


delta(E*) ::= D(E*)*
where
   D(E*) ::= delete(k)
   	  | change(k, D(E))
	  | insert(k, E)


delta(S^) ::= // just update symbol


-----
start Machine

Machine ::= [StateMachine] "start" Change.State.ref StateMachine.states.delta*

Statemachine.states.delta ::= Change.State | Remove.State

Change.State.ref ::= (! \start:sym )
		 | ...
			 

MachineStates ::= states:StateD*
	       |  ...

StatesStateD ::= (- State^) 
        |  (+ State) // in a plus, State should not be a delta but a plain state
	|  StateD

State ::= [State] "state" name:sym Enter? Leave? out:Transition*

StateD ::= [State] "state" StateName StateEnter StateLeave out:Transition*

StateName ::= name:sym
	   | (! name:sym)

StateEnter ::= (+ Enter)
	    |  (-)
	    | (Enter ...)

StateLeave ::= (+ Leave)
	    | (-)
	    | (Leave ...)


StateTransition ::= (+ Transition)
		 |  (- Transition^) // positions?
		 | ...
		 | TransitionD

TransitionD ::= "on" TransitionEvent TransitionAction "go" TransitionTo

TransitionEvent ::= (! event:str)
		 | ...

TransitionAction ::= (+ Action)
		  | (-)
		  | ...
		  | ActionD

ActionD ::= "do" ActionAction

ActionAction ::= (! action:str)

TransitionTo ::= (! to:State^)
	      |  ...


MachineStart ::= \start:State^
	      |  (! \start:State^ )
	      | "..."

