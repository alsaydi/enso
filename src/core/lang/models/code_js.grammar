start Program

Program ::= [Module] "define(["/> requires:([Require] path:str)* @(.","/) </"]," /
                     "function(". requires:([Require] name:sym)* @(.",") .") {">/2
                     "var" name:sym ";"/
                     defs:Def* @/2 /2
                     name:sym "=" "{"/> defs:Export* /2 /<"};"/
                     "return" name:sym .";"/
                     <"})"/
Def     ::= Class | Mixin | [Binding]
Export ::= [Class] ExportName | [Mixin] ExportName | Binding
ExportName ::= name:sym .":" name:sym ."," /
Binding  ::= [Binding] name:sym .":" (value:Function | value:Expr) ","/2
  Function ::= FunHeader FunBody
  
// class N < N 
//   D* 
// end
// class 
// D ::= def N 

Class   ::= [Class] "var" name:sym "= MakeClass(" (parent:sym .",")? "{" Body "});"
Mixin   ::= [Mixin] "var" name:sym "= MakeMixin({" Body "});"
Body    ::= /> Includes? Meta? defs:DefB* @(.","/2) </
Includes ::= "include: [" includes:Include+ @"," "]," /2
  Include ::= [Include] (module:sym.".")? name:sym

Meta    ::= "_class_:" "{"/> meta:DefB+ @(.","/2) </"}," /2
DefB     ::= Attribute | BindingB
BindingB  ::= [Binding] MethodSym .":" (Method | value:Expr)
  MethodSym ::= {name=="[]"} "_get" | {name=="[]="} "_set" | name:sym
Method   ::= value:FunHeader SuperBind value:FunBody
  FunHeader ::= [Fun] "function(". Params .") {" /> "var self = this; "/ args:Default* VarArg? Locals?
    VarArg ::= "var" rest:sym "= compute_rest_arguments(arguments," num_args:int ");" /
    Locals ::= "var" locals:Decl+ @(.",") .";" /
  Decl     ::= [Decl] name:sym ("=" default:Expr)?
  SuperBind ::= "var super$ = this.super$.". MethodSym .";" /
  FunBody ::= [Fun] body:SeqBodyR </"}"
   
Attribute ::= [Attribute] ({ kind=="attr_reader" } Reader | { kind=="attr_accessor" } Reader .","/ Writer)
Reader  ::= name:sym .":" "function()" "{" "return" "this"."."."$".".". name:sym "}"
Writer  ::= "set_".name:sym .":" "function(val)" "{" "this"."."."$".".". name:sym " = val" "}"

Seq     ::= "{"/> SeqBody </"}"
SeqBody     ::= [Seq] statements:Statement* @/ | Statement
SeqR     ::= "{"/> SeqBodyR </"}"
SeqBodyR     ::= [Seq] statements:StatementLR* @/ | StatementR

Statement ::= Basic | Expr .";"
StatementR ::= BasicR | "return" Expr .";"
StatementLR ::= {_last} StatementR | Statement
Basic   ::= If | While | TryCatch
If      ::= [If] "if" "(". cond:Expr .")" sthen:Seq ("else" (selse:If | selse:Seq))?
While   ::= [While] "while" "(". cond:Expr .")" body:Seq
TryCatch ::= [Rescue] "try" base:Seq rescues:Handler* ("finally" ensure:Seq)? 
Handler ::= [Handler] "catch" "(" (var:sym | "DUMMY") ")" body:Seq // TODO: deal with kind:str!!!

BasicR   ::= IfR | While | TryCatchR
IfR      ::= [If] "if" "(". cond:Expr .")" sthen:SeqR ("else" (selse:IfR | selse:SeqR))?
TryCatchR ::= [Rescue] "try" base:SeqR rescues:HandlerR* ("finally" ensure:Seq)? 
HandlerR ::= [Handler] "catch" "(" (var:sym | "DUMMY") ")" body:SeqR // TODO: deal with kind:str!!!

Expr ::= IndexAssign | Assign
IndexAssign ::= [Assign] to:IndexTarget "._set(" to:IndexIndex "," from:Assign ")"
IndexTarget ::= [Index] base:Primary 
IndexIndex ::= [Index] index:Expr
 
Assign  ::= [Assign] to:Primary "=" from:Assign
        | EOr
EOr ::= [EBinOp] e1:EAnd op:"||" e2:EOr
       | EAnd
EAnd ::= [EBinOp] e1:EBinOp1 op:"&&" e2:EAnd
        | EBinOp1
EBinOp1 ::= [EBinOp] e1:EBinOp2 (op:"==" | op:"!=") e2:EBinOp1
         | EBinOp2
EBinOp2 ::= [EBinOp] e1:EBinOp3 (op:">" | op:"<" | op:">=" | op:"<=") e2:EBinOp2
         | EBinOp3
EBinOp3 ::= [EBinOp] e1:EBinOp3 (op:"<<" | op:">>" | op:"++") e2:EBinOp4
         | EBinOp4
EBinOp4 ::= [EBinOp] e1:EBinOp5 (op:"+" | op:"-") e2:EBinOp4
         | EBinOp5
EBinOp5 ::= [EBinOp] e1:EUnOp (op:"*" | op:"/" | op:"%") e2:EBinOp5
         | EUnOp
EUnOp ::= [EUnOp] (op:"!" | op:"-") e:EUnOp
        | EBinOp6
EBinOp6 ::= [EBinOp] e1:Primary op:"**" e2:EBinOp6
         | Primary


Primary ::= InstVar | ClassVar | Nil | Var | Super |  IfE | List | Index | Record | Fun | Call | Lit | "(". Expr .")" | 
             "((function(){" SeqR "})())"
Nil     ::= [Var] "null" { name == "nil" }
Var     ::= [Var] name:sym
InstVar ::= [Var] "self"."."."$".".". name:sym { kind=="@" }
ClassVar::= [Var] "self"."."."_class_".".". name:sym { kind=="@@" }
List    ::= [List] "[". items:Expr* @(.",") ."]"
Index   ::= [Index] base:Primary ."._get(". index:Expr .")"
Record  ::= [Record] "new" "EnsoHash" "(" "{" fields:Field* @(.",") "}" ")"
  Field   ::= [Binding] name:sym .":" value:Expr
Lit     ::= [Lit] value:atom
IfE      ::= [If] cond:Expr /> "?" sthen:Expr / ":" selse:Expr </    // TODO: Precedence!!

Call     ::= SuperCallRest | SuperCall | CallRest | CallNorm
CallRest  ::= [Call] target:Primary .".". method:sym ".call_rest_args$(".target:Primary ."," (Args.",")? rest:Expr ")"
CallNorm  ::= [Call] (target:Primary .".".)? method:sym ({method=="length"} | ."(". Args? .")")
  Args    ::= (block:Fun .",")? args:Expr+ @(.",") 
            | block:Fun
SuperCallRest ::= [Call] target:Super "super$.call_rest_args$(self," (Args.",")? rest:Expr ")"
SuperCall     ::= [Call] target:Super "super$.call(self" (."," Args)? .")"
  Super ::= [Super] 
  
Fun     ::= [Fun] "function(". Params .")" "{"/> args:Default* body:SeqBodyR </"}"
Params  ::=  (block:sym .",")? args:Param+ @(.",")
          | block:sym?
Param     ::= [Decl] name:sym
Default     ::= [Decl] ("if (". name:sym "=== undefined)" name:sym "=" default:Expr .";" /)?
  