start Program

Program ::= [Module] defs:Top*
Top     ::=  Require | MainModule
Require ::= [Directive] action:"require" "(" what:Expr ")"
MainModule ::= [Module] defs:Def* meta:Binding*
Def     ::= Binding | Class | Module
Binding  ::= [Binding] name:sym "=" value:Expr

// class N < N 
//   D* 
// end
// class 
// D ::= def N 

Module  ::= [Module] name:sym "= EnsoModule({" Body "})"
Class   ::= [Class] name:sym "= EnsoClass(" (parent:sym .",")? "{" Body "})"
Body    ::= Meta? defs:DefB* @","
Meta    ::= "extend" ":" "{" meta:DefB* @"," "},"
DefB     ::= BindingB | Directive
BindingB  ::= [Binding] name:sym ":" ({name=="initialize"} value:Method | value:MethodR | value:Expr)
Method   ::= [Fun] "function" Params "{ var self=this;" body:SeqBody "}"
MethodR ::= [Fun] "function" Params "{ var self=this;" body:SeqR "}"

Directive ::= Attr | Include
Include ::= [Directive] action:"include" ":" what:LitName
Attr    ::= [Directive] { action=="attr_reader" } Reader
Reader  ::= what:LitName ":" "function" "(" ")" "{" "return" "this"."."."AT$"."." what:LitName "}"
// Writer  ::= "set".what:LitName ":" "function" "(val)" "{" "this"."."."AT$"."." what:LitName "=val" "}"
LitName ::= [Lit] value:sym

Seq     ::= "{" SeqBody "}"
SeqBody     ::= [Seq] statements:Statement* | Statement
SeqR     ::= "{" SeqBodyR "}"
SeqBodyR     ::= [Seq] statements:StatementLR* | StatementR

Statement ::= Basic | Expr ";"
StatementR ::= BasicR | "return" Expr ";"
StatementLR ::= {_last} StatementR | Statement
Basic   ::= If | While | TryCatch
If      ::= [If] "if" "(". cond:Expr .")" sthen:Seq ("else" (selse:If | selse:Seq))?
While   ::= [While] "while" "(". cond:Expr .")" body:Seq
TryCatch ::= [Rescue] "try" base:Seq rescues:Handler* ("finally" ensure:Seq)? 
Handler ::= [Handler] "catch" "(" (var:str | "DUMMY") ")" body:Seq // TODO: deal with kind:str!!!

BasicR   ::= IfR | While | TryCatchR
IfR      ::= [If] "if" "(". cond:Expr .")" sthen:SeqR ("else" (selse:IfR | selse:SeqR))?
TryCatchR ::= [Rescue] "try" base:SeqR rescues:HandlerR* ("finally" ensure:Seq)? 
HandlerR ::= [Handler] "catch" "(" (var:str | "DUMMY") ")" body:SeqR // TODO: deal with kind:str!!!

Expr ::= Assign
Assign  ::= [Assign] to:Primary "=" from:Assign
        | EOr
EOr ::= [EBinOp] e1:EAnd op:"||" e2:EOr
       | EAnd
EAnd ::= [EBinOp] e1:EBinOp1 op:"&&" e2:EAnd
        | EBinOp1
EBinOp1 ::= [EBinOp] e1:EBinOp2 (op:"==" | op:"!=") e2:EBinOp1
         | EBinOp2
EBinOp2 ::= [EBinOp] e1:EBinOp3 (op:">" | op:"<" | op:">=" | op:"<=") e2:EBinOp2
         | EBinOp3
EBinOp3 ::= [EBinOp] e1:EBinOp3 (op:"<<" | op:">>" | op:"++") e2:EBinOp4
         | EBinOp4
EBinOp4 ::= [EBinOp] e1:EBinOp5 (op:"+" | op:"-") e2:EBinOp4
         | EBinOp5
EBinOp5 ::= [EBinOp] e1:EUnOp (op:"*" | op:"/" | op:"%") e2:EBinOp5
         | EUnOp
EUnOp ::= [EUnOp] (op:"!" | op:"-") e:EUnOp
        | EBinOp6
EBinOp6 ::= [EBinOp] e1:Primary op:"**" e2:EBinOp6
         | Primary


Primary ::= InstVar | ClassVar | Nil | Var |  IfE | List | Record | Fun | Call | Lit | "(". Expr .")" | 
             "((function(){" SeqR "})())"
Nil     ::= [Var] "null" { name == "nil" }
Var     ::= [Var] name:sym
InstVar ::= [Var] "self"."."."AT$".".". name:sym { kind=="@" }
ClassVar::= [Var] "self"."."."klass".".". name:sym { kind=="@@" }
List    ::= [List] "[". items:Expr* @"," ."]"
Record  ::= [Record] "new" "EnsoHash" "(" "{" fields:Field* @"," "}" ")"
  Field   ::= [Binding] name:sym .":" value:Expr
Lit     ::= [Lit] value:(str | int | real)
IfE      ::= [If] cond:Expr "?" sthen:Expr ":" selse:Expr  // TODO: Precedence!!

Call  ::= [Call] (target:Primary .".".)? name:sym Args
  Args    ::= ."(". args:Primary+ @(.",") ("," block:Fun)? .")"
            | ."(". block:Fun? .")"
Fun     ::= [Fun] "function" Params body:SeqR
Params  ::= "(". args:Arg* @(.",") .")"
Arg     ::= [Arg] name:sym ("=" default:Expr)?


