

start Schema

abstract Schema

Body ::= body:{Expression ";"}+

// TODO: this is ambiguous, use at own risk
Expression ::= [Variable] name:sym
	    | Value

	    | [Lookup] obj:Expression "[" key:Expression "]"
	    | [Update] obj:Expression "[" contents:{Assign ";"}* "]"
	    | [Dot]  obj:Expression "->" field:sym

	    | [Unary] op:"!" arg:Expression
	    | [Binary] lhs:Expression op:"+" rhs:Expression
	    | [Binary] lhs:Expression op:"*" rhs:Expression
	    | [Binary] lhs:Expression op:"==" rhs:Expression
	    | [Binary] lhs:Expression op:"!=" rhs:Expression
	    | [Binary] lhs:Expression op:">" rhs:Expression
	    | [Binary] lhs:Expression op:"<" rhs:Expression
	    | [Binary] lhs:Expression op:">=" rhs:Expression
	    | [Binary] lhs:Expression op:"<=" rhs:Expression

	    | [IfThen] "if" conds:{Condition ","}+ "then" Body
	      	       elsifs:ElsIf* else:Else? "end"
  	    | [For] "for" conds:{Condition ","}+ "do" Body "end"

            | [Call] name:sym "(" args:{Argument ","}* ")"
            | [Cons] type:sym  "{" contents:{Assign ";"}* "}"

	    | [Let] "let" bindings:{Binding ";"}+ "in" Body "end"

	    | "(" Expression ")"
	    

Binding ::= [Binding] name:sym Many? "=" expression:Expression

Many ::= "*" @"@many = true"

Argument ::= [Splat] "*" arg:Expression
	  | Expression


Value ::= [Int] value:int
       | [Str] value:str
       | [Bool] Bool


Bool ::= [Bool] "true" @"value = true"
      |  [Bool] "false" @"value = false"

Assign ::= [Assign] name:sym ":" expressions:{Expression ","}*

ElsIf ::= [IfThen] "elsif" cond:Expression "then" Body
Else ::= [Else] "else" Body

Condition ::= Expression
           |  [Generator] var:sym "<-" expression:Expression
