require "core/system/utils/paths"
require "core/schema/code/factory"
require "json"
require "enso"

module Boot2
  class MObject < EnsoProxyObject
    @@seq_no = 0
    attr_reader "_id"
    def initialize(data, root)
      
      @_id = @@seq_no = @@seq_no + 1;
      @data = data;
      @root = root || self;
    end
    def schema_class
      local :res
      res = @root.types[@data["class"]];
      self.define_singleton_method("schema_class") do
        res;
      end
      res;
    end
    def _get(sym)
      local :res
      res = if sym[- 1] == "?" then
        self.schema_class.name == sym.slice(0, sym.length - 1);
      elsif @data.has_key_p(S(sym, "=")) then
        @data[S(sym, "=")];
      elsif @data.has_key_p(S(sym, "#")) then
        Boot2.make_field(@data[S(sym, "#")], @root, true);
      elsif @data.has_key_p(sym.to_s) then
        Boot2.make_field(@data[sym.to_s], @root, false);
      else
        System.raise(S("Trying to deref nonexistent field ", sym, " in ", @data.to_s.slice(0, 300)));
      end
      self.define_singleton_method(sym) do
        res;
      end
      res;
    end
    def eql_p(other)
      
      self._id == other._id;
    end
    def to_s
      
      @name || (
        @name = begin
          S("<", @data["class"], " ", self.name, ">");
        rescue
          S("<", @data["class"], " ", self._id, ">");
        end
      );
    end
  end

  class Schema < MObject
    def classes
      
      BootManyField.new((
        self.types.select do |t|
          t.Class_p;
        end
      ), @root, true);
    end
    def primitives
      
      BootManyField.new((
        self.types.select do |t|
          t.Primitive_p;
        end
      ), @root, true);
    end
  end

  class Class < MObject
    def all_fields
      
      BootManyField.new((
        self.supers.flat_map do |s|
          s.all_fields;
        end
      ) + self.defined_fields, @root, true);
    end
    def fields
      
      BootManyField.new((
        self.all_fields.select do |f|
          ! f.computed;
        end
      ), @root, true);
    end
  end

  class BootManyField < Array
    def initialize(arr, root, keyed)
      
      arr.each do |obj|
        self.push(obj);
      end
      @root = root;
      @keyed = keyed;
    end
    def [](key)
      
      if @keyed then
        self.find do |obj|
          obj.name == key;
        end
      else
        self.at(key);
      end
    end
    def has_key_p(key)
      
      self[key];
    end
    def each_with_match(other, &block)
      local :other , :ks , :a , :b
      if @keyed then
        other = other || {};
        ks = self.keys || other.keys;
        ks.each do |k|
          block.call(self[k], other[k]);
        end
      else
        a = Array(self);
        b = Array(other);
        Range.new(0, [a.length, b.length].max - 1).each do |i|
          block.call(a[i], b[i]);
        end
      end
    end
    def keys
      
      if @keyed then
        self.map do |o|
          o.name;
        end
      else
        nil;
      end
    end
  end
  def self.load_path(path)
    
    Boot2.load(System.readJSON(path));
  end

  def self.load(doc)
    local :ss0
    ss0 = Boot2.make_object(doc, nil);
    Copy(ManagedData.new(ss0), ss0);
  end

  def self.make_object(data, root)
    
    if data["class"] == "Schema" then
      Schema.new(data, root);
    elsif data["class"] == "Class" then
      Class.new(data, root);
    else
      MObject.new(data, root);
    end
  end

  def self.make_field(data, root, keyed)
    
    if data.is_a_p(Array) then
      Boot2.make_many(data, root, keyed);
    else
      Boot2.get_object(data, root);
    end
  end

  def self.get_object(data, root)
    
    if ! data then
      nil;
    elsif data.is_a_p(String) then
      Paths.parse(data).deref(root);
    else
      Boot2.make_object(data, root);
    end
  end

  def self.make_many(data, root, keyed)
    local :arr
    arr = data.map do |a|
      Boot2.get_object(a, root);
    end
    BootManyField.new(arr, root, keyed);
  end
end

