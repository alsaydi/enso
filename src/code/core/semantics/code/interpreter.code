

module Interpreter
  class DynamicPropertyStack

    def initialize
      @current = {};
      @stack = [];
    end

    def [](name)
      @current[name];
    end

    def _bind(field, value)
      local :old
      old = @current[field];
      @stack.push([field, old]);
      @current[field] = value;
    end

    def _pop(n = 1)
      local :parts
      while n > 0 do
        parts = @stack.pop;
        @current[parts[0]] = parts[1];
        n = n - 1;
      end
    end

    def to_s
      @current.to_s;
    end
  end

  module Dispatcher

    attr_accessor :_

    def dynamic_bind(fields, &block)
      local :result
      if ! @D then
        @D = DynamicPropertyStack.new;
      end
      fields.each do |key, value|
        @D._bind(key, value);
      end
      result = block.call;
      @D._pop(fields.size);
      result;
    end

    def dispatch(operation, obj)
      local :type , :method , :params
      type = obj.schema_class;
      method = S(operation, "_", type.name).to_s;
      if ! self.respond_to_P(method) then
        method = self.find(operation, type);
      end
      if ! method then
        method = S(operation, "_?").to_s;
        if ! self.respond_to_P(method) then
          self.raise(S("Missing method in interpreter for ", operation, "_", type.name, "(", obj, ")"));
        end
        self.send(method, type, obj, @D);
      else
        params = type.fields.map do |f|
          obj[f.name];
        end
        self.send(method, *params);
      end
    end

    def dispatch_obj(operation, obj)
      local :type , :method
      type = obj.schema_class;
      method = S(operation, "_", type.name).to_s;
      if ! self.respond_to_P(method) then
        method = self.find(operation, type);
      end
      if ! method then
        method = S(operation, "_?").to_s;
        if ! self.respond_to_P(method) then
          self.raise(S("Missing method in interpreter for ", operation, "_", type.name, "(", obj, ")"));
        end
      end
      self.send(method, obj);
    end

    def find(operation, type)
      local :method
      method = S(operation, "_", type.name).to_s;
      if self.respond_to_P(method) then
        method;
      else
        type.supers.find_first do |p|
          self.find(operation, p);
        end
      end
    end
  end
end
