require "core/schema/code/many" # Many
require "core/schema/code/dynamic" # Dynamic
require "core/system/utils/paths" # Paths
require "core/system/library/schema" # Schema
require "core/semantics/code/interpreter" # Interpreter
require "core/expr/code/impl" # Impl
require "core/expr/code/env" # Env
require "core/expr/code/freevar" # Freevar

module ManagedData
  @ new = (
    do |schema|
      Factory.new(schema);
    end
  )

  class Factory

    attr_reader :schema

    attr_accessor :file_path

    def initialize(schema)
      @schema = schema;
      @roots = [];
      @file_path = [];
      schema.classes.each do |klass|
        self.define_singleton_method(klass.name) do |*args|
          MObject.new(klass, self, *args);
        end
      end
    end

    def [](name)
      self.send(name);
    end

    def register(root)
      if @root then
        self.raise("Creating two roots");
      end
      @root = root;
    end
  end

  class MObject < EnsoProxyObject

    @@_id = 0

    attr_accessor :_origin

    attr_accessor :__shell

    attr_reader :_id

    attr_reader :factory

    attr_accessor :extra_instance_data

    def initialize(klass, factory, *args)
      @_id = @@_id = @@_id + 1;
      @listeners = {};
      @props = {};
      self.define_singleton_value("schema_class", klass);
      @factory = factory;
      self.__is_a(klass);
      self.__to_s(klass);
      klass.all_fields.each do |fld|
        self.__setup(fld);
      end
      klass.fields.each_with_index do |fld, i|
        if i < args.length then
          if fld.many then
            args[i].each do |value|
              self[fld.name].push(value);
            end
          else
            self[fld.name] = args[i];
          end
        end
      end
    end

    def __setup(fld)
      local :prop , :key , :collection
      if fld.computed then
        self.__computed(fld);
      elsif ! fld.many then
        if fld.type.Primitive_P then
          prop = ManagedData.Prim.new(self, fld);
        else
          prop = ManagedData.Ref.new(self, fld);
        end
        @props[fld.name] = prop;
        self.define_getter(fld.name, prop);
        self.define_setter(fld.name, prop);
      else
        if (
          key = Schema.class_key(fld.type);
        ) then
          collection = ManagedData.Set.new(self, fld, key);
        else
          collection = ManagedData.List.new(self, fld);
        end
        @props[fld.name] = collection;
        self.define_singleton_value(fld.name, collection);
      end
    end

    def __get(name)
      @props[name];
    end

    def __is_a(klass)
      local :val
      klass.schema.classes.each do |cls|
        val = Schema.subclass_P(klass, cls);
        self.define_singleton_value(S(cls.name, "?"), val);
      end
    end

    def __to_s(cls)
      local :k
      k = Schema.class_key(cls);
      if k then
        self.define_singleton_method("to_s") do
          S("<<", cls.name, " ", self._id, " '", self[k.name], "'>>");
        end
      else
        self.define_singleton_value("to_s", S("<<", cls.name, " ", self._id, ">>"));
      end
    end

    def __computed(fld)
      local :c , :base , :name , :exp , :fvInterp , :commInterp , :val , :fvs , :var_V
      if fld.computed.EList_P && (
        c = fld.owner.supers.find do |c|
          c.all_fields[fld.name];
        end
      ) then
        base = c.all_fields[fld.name];
        if base.inverse then
          fld.computed.elems.each do |var_V|
            if ! var_V.EVar_P then
              self.raise(S("Field override ", fld.name, " includes non-var ", var_V));
            end
            self.__get(var_V.name)._set_inverse = base.inverse;
          end
        end
      end
      name = fld.name;
      exp = fld.computed;
      fvInterp = FreeVar.FreeVarExprC.new;
      commInterp = Impl.EvalCommandC.new;
      val = nil;
      self.define_singleton_method(name) do
        if val == nil then
          fvs = fvInterp.dynamic_bind({}) do
            fvInterp.depends(exp);
          end
          fvs.each do |fv|
            if fv.object then
              fv.object.add_listener(fv.index) do
                var_V = nil;
              end
            end
          end
          val = commInterp.dynamic_bind({}) do
            commInterp.eval(exp);
          end
          var_V = val;
        end
        val;
      end
    end

    def _graph_id
      @factory;
    end

    def instance_of_P(sym)
      self.schema_class.name == sym.to_s;
    end

    def delete_in_place
      self.factory.delete_in_place(self);
    end

    def __delete_obj(mobj)
      self.schema_class.fields.each do |fld|
        if fld.traversal then
          self.__get(fld.name).__delete_obj(mobj);
        end
      end
    end

    def dynamic_update
      @dyn = @dyn || DynamicUpdateProxy.new(self);
    end

    def add_listener(name, &block)
      local :listeners
      listeners = @listeners[name];
      if ! listeners then
        listeners = @listeners[name] = [];
      end
      listeners.push(block);
    end

    def notify(name, val)
      if @listeners[name] then
        @listeners[name].each do |blk|
          blk.call(val);
        end
      end
    end

    def _origin_of(name)
      self.__get(name)._origin;
    end

    def _set_origin_of(name, org)
      self.__get(name)._origin = org;
    end

    def _path_of(name)
      self._path.field(name);
    end

    def _path
      if self.__shell then
        self.__shell._path(self);
      else
        Paths.new;
      end
    end

    def _clone
      local :r
      r = MObject.new(self.schema_class, @factory);
      self.schema_class.fields.each do |field|
        if field.many then
          self[field.name].each do |o|
            r[field.name].push(o);
          end
        else
          r[field.name] = self[field.name];
        end
      end
      r;
    end

    def eql_P(o)
      self == o;
    end

    def equals(o)
      (o && System.test_type(o, MObject)) && self._id == o._id;
    end

    def hash
      @_id;
    end

    def finalize
      self.factory.register(self);
      self;
    end
  end

  class Field

    attr_accessor :_origin

    def initialize(owner, field)
      @owner = owner;
      @field = field;
      if field then
        @inverse = field.inverse;
      end
    end

    def set__set_inverse(inv)
      if @inverse then
        self.raise(S("Overiding inverse of field '", inv.owner.name, ".", self.invk.name, "'"));
      end
      @inverse = inv;
    end

    def __delete_obj(mobj)
    end

    def to_s
      S(".", @field.name, " = ", @value);
    end
  end

  class Single < Field

    def initialize(owner, field)
      super(owner, field);
      @value = self.default_V;
    end

    def set(value)
      self.check(value);
      @value = value;
      @owner.notify(@field.name, value);
    end

    def get
      @value;
    end

    def init(value)
      self.set(value);
    end

    def default
      nil;
    end
  end

  class Prim < Single

    def check(value)
      local :ok
      if ! @field.optional || value then
        ok = if @field.type.name == "str" then
          System.test_type(value, String);
        elsif @field.type.name == "int" then
          System.test_type(value, Integer);
        elsif @field.type.name == "bool" then
          System.test_type(value, TrueClass) || System.test_type(value, FalseClass);
        elsif @field.type.name == "real" then
          System.test_type(value, Numeric);
        elsif @field.type.name == "datetime" then
          System.test_type(value, DateTime);
        elsif @field.type.name == "atom" then
          ((System.test_type(value, Numeric) || System.test_type(value, String)) || System.test_type(value, TrueClass)) || System.test_type(value, FalseClass);
        end
        if ! ok then
          self.raise(S("Invalid value for ", @field.name, ":", @field.type.name, " = ", value));
        end
      end
    end

    def default
      if ! @field.optional then
        if @field.type.name == "str" then
          "";
        elsif @field.type.name == "int" then
          0;
        elsif @field.type.name == "bool" then
          false;
        elsif @field.type.name == "real" then
          0.0;
        elsif @field.type.name == "datetime" then
          DateTime.now;
        elsif @field.type.name == "atom" then
          nil;
        else
          self.raise(S("Unknown primitive type: ", @field.type.name));
        end
      end
    end
  end

  module RefHelpers

    def notify(old, new_V)
      if old != new_V then
        @owner.notify(@field.name, new_V);
        if @inverse then
          if @inverse.many then
            if old then
              old.__get(@inverse.name).__delete(@owner);
            end
            if new_V then
              new_V.__get(@inverse.name).__insert(@owner);
            end
          else
            if old then
              old.__get(@inverse.name).__set(nil);
            end
            if new_V then
              new_V.__get(@inverse.name).__set(@owner);
            end
          end
        end
      end
    end

    def check(mobj)
      if mobj || ! @field.optional then
        if mobj == nil then
          self.raise(S("Cannot assign nil to non-optional field ", @field.name));
        end
        if ! Schema.subclass_P(mobj.schema_class, @field.type) then
          self.raise(S("Invalid value for '", @field.owner.name, ".", @field.name, "': ", mobj, " : ", mobj.schema_class.name));
        end
        if mobj._graph_id != @owner._graph_id then
          self.raise(S("Inserting object ", mobj, " into the wrong model"));
        end
      end
    end
  end

  class Ref < Single
    include RefHelpers

    def set(value)
      self.check(value);
      self.notify(self.get, value);
      self.__set(value);
    end

    def __set(value)
      if @field.traversal then
        if value then
          value.__shell = self;
        end
        if self.get && ! value then
          self.get.__shell = nil;
        end
      end
      @value = value;
    end

    def _path(_)
      @owner._path.field(@field.name);
    end

    def __delete_obj(mobj)
      if self.get == mobj then
        self.set(nil);
      end
    end
  end

  class Many < Field
    include RefHelpers
    include Enumerable

    def get
      self;
    end

    def set
      self.raise(S("Cannot assign to many-valued field ", @field.name));
    end

    def init(values)
      values.each do |value|
        self.push(value);
      end
    end

    def __value
      @value;
    end

    def [](key)
      self.__value[key];
    end

    def empty_P
      self.__value.empty_P;
    end

    def length
      self.__value.length;
    end

    def to_s
      self.__value.to_s;
    end

    def clear
      self.__value.clear;
    end

    def connected_P
      @owner;
    end

    def has_key_P(key)
      self.keys.include_P(key);
    end

    def check(mobj)
      if self.connected_P then
        super(mobj);
      end
    end

    def notify(old, new_V)
      if self.connected_P then
        super(old, new_V);
      end
    end

    def __delete_obj(mobj)
      if self.values.include_P(mobj) then
        self.delete(mobj);
      end
    end

    def connect(mobj, shell)
      if self.connected_P && @field.traversal then
        mobj.__shell = shell;
      end
    end
  end

  class Set < Many
    include SetUtils

    def initialize(owner, field, key)
      super(owner, field);
      @value = {};
      @key = key;
    end

    def each(&block)
      self.__value.each_value(&block);
    end

    def each_pair(&block)
      self.__value.each_pair(&block);
    end

    def find_first_pair(&block)
      self.__value.find_first_pair(&block);
    end

    def values
      self.__value.values;
    end

    def keys
      self.__value.keys;
    end

    def _recompute_hash_in_place
      local :nval
      nval = {};
      @value.each do |k, v|
        nval[v[@key.name]] = v;
      end
      @value = nval;
      self;
    end

    def push(mobj)
      local :key
      self.check(mobj);
      key = mobj[@key.name];
      if ! key then
        self.raise(S("Nil key when adding ", mobj, " to ", self));
      end
      if @value[key] != mobj then
        if @value[key] then
          self.delete(@value[key]);
        end
        self.notify(@value[key], mobj);
        self.__insert(mobj);
      end
      self;
    end

    def []=(index, mobj)
      self.push(mobj);
    end

    def delete(mobj)
      local :key
      key = mobj[@key.name];
      if @value.has_key_P(key) then
        self.notify(@value[key], nil);
        self.__delete(mobj);
      end
    end

    def _path(mobj)
      @owner._path.field(@field.name).key(mobj[@key.name]);
    end

    def __insert(mobj)
      self.connect(mobj, self);
      @value[mobj[@key.name]] = mobj;
    end

    def __delete(mobj)
      local :deleted
      deleted = @value.delete(mobj[@key.name]);
      self.connect(deleted, nil);
      deleted;
    end
  end

  class List < Many
    include ListUtils

    def initialize(owner, field)
      super(owner, field);
      @value = [];
    end

    def [](key)
      self.__value[key.to_i];
    end

    def each(&block)
      self.__value.each(&block);
    end

    def each_pair(&block)
      self.__value.each_with_index do |item, i|
        block.call(i, item);
      end
    end

    def values
      self.__value;
    end

    def keys
      Array.new(self.length) do |i|
        i;
      end
    end

    def push(mobj)
      if ! mobj then
        self.raise("Cannot insert nil into list");
      end
      self.check(mobj);
      self.notify(nil, mobj);
      self.__insert(mobj);
      self;
    end

    def []=(index, mobj)
      local :old
      if ! mobj then
        self.raise("Cannot insert nil into list");
      end
      old = self.__value[index.to_i];
      if old != mobj then
        self.check(mobj);
        self.notify(nil, mobj);
        self.__value[index.to_i] = mobj;
        if old then
          self.notify(old, nil);
        end
      end
      self;
    end

    def delete(mobj)
      local :deleted
      deleted = self.__delete(mobj);
      if deleted then
        self.notify(deleted, nil);
      end
      deleted;
    end

    def insert(index, mobj)
      if ! mobj then
        self.raise("Cannot insert nil into list");
      end
      self.check(mobj);
      self.notify(nil, mobj);
      @value.insert(index.to_i, mobj);
      self;
    end

    def _path(mobj)
      @owner._path.field(@field.name).index(@value.index(mobj));
    end

    def __insert(mobj)
      self.connect(mobj, self);
      @value.push(mobj);
    end

    def __delete(mobj)
      local :deleted
      deleted = @value.delete(mobj);
      self.connect(deleted, nil);
      deleted;
    end
  end
end
