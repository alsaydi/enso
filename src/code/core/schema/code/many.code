

module ManagedData
  module SetUtils

    def to_ary
      @values.values;
    end

    def add(other)
      local :r
      r = self.inject(Set.new(nil, @field, self.__key || other.__key)) do |x|
        x.push;
      end
      other.inject(r) do |x|
        x.push;
      end
    end

    def select(&block)
      local :result
      result = Set.new(nil, @field, self.__key);
      self.each do |elt|
        if block.call(elt) then
          result.push(elt);
        end
      end
      result;
    end

    def flat_map(&block)
      local :new_V , :set , :key
      new_V = nil;
      self.each do |x|
        set = block.call(x);
        if new_V.nil_P then
          key = set.__key;
          new_V = Set.new(nil, @field, key);
        else
        end
        set.each do |y|
          new_V.push(y);
        end
      end
      new_V || Set.new(nil, @field, self.__key);
    end

    def each_with_match(other, &block)
      local :empty
      empty = Set.new(nil, @field, self.__key);
      self.__outer_join(other || empty) do |sa, sb|
        if (sa && sb) && sa[self.__key.name] == sb[self.__key.name] then
          block.call(sa, sb);
        elsif sa then
          block.call(sa, nil);
        elsif sb then
          block.call(nil, sb);
        end
      end
    end

    def __key
      @key;
    end

    def __keys
      @value.keys;
    end

    def __outer_join(other, &block)
      local :keys
      keys = self.__keys.union(other.__keys);
      keys.each do |key|
        block.call(self[key], other[key], key);
      end
    end
  end

  module ListUtils

    def each_with_match(other, &block)
      if ! self.empty_P then
        self.each do |item|
          block.call(item, nil);
        end
      end
    end
  end
end
