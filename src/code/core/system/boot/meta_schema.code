require "core/system/utils/paths" # Paths
require "core/schema/code/factory" # Factory
require "json" # Json
require "enso" # Enso

module Boot
  @ load_path = (
    do |path|
      Boot.load(System.readJSON(path)["model"]);
    end
  )

  @ load = (
    do |doc|
      ss0 = Boot.make_object(doc, nil);
      ss0._complete;
      Copy(ManagedData.new(ss0), ss0);
    end
  )

  @ make_object = (
    do |data, root|
      if data != nil then
        if data["class"] == "Schema" then
          Schema.new(data, root);
        elsif data["class"] == "Class" then
          Class.new(data, root);
        else
          MObject.new(data, root);
        end
      end
    end
  )

  class MObject < EnsoProxyObject

    @@seq_no = 0

    attr_reader :_id

    attr_accessor :factory

    attr_accessor :_path

    attr_reader :file_path

    def initialize(data, root)
      local :has_name , :keyed , :name
      @_id = @@seq_no = @@seq_no + 1;
      @factory = self;
      @file_path = [];
      @root = root || self;
      @data = data;
      has_name = false;
      data.each do |key, value|
        if key == "class" then
        elsif key[- 1] == "=" then
          self.define_singleton_value(key.slice(0, key.length - 1), value);
          if key == "name=" then
            has_name = true;
            self.define_singleton_value("to_s", S("<", data["class"], " ", self._id, " ", value, ">"));
          end
        elsif System.test_type(value, Array) then
          keyed = key[- 1] == "#";
          name = if keyed then
            key.slice(0, key.length - 1);
          else
            key;
          end
          if value.length == 0 || ! System.test_type(value[0], String) then
            self._create_many(name, (
              value.map do |a|
                Boot.make_object(a, @root);
              end
            ), keyed);
          end
        elsif ! System.test_type(value, String) then
          self.define_singleton_value(key, Boot.make_object(value, @root));
        end
      end
      if ! has_name then
        self.define_singleton_value("to_s", S("<", data["class"], " ", self._id, ">"));
      end
    end

    def _complete
      local :keyed , :name
      @data.each do |key, value|
        if key == "class" then
          self.define_singleton_value("schema_class", @root.types[value]);
        elsif key[- 1] != "=" && value then
          if System.test_type(value, Array) then
            keyed = key[- 1] == "#";
            name = if keyed then
              key.slice(0, key.length - 1);
            else
              key;
            end
            if value.length > 0 && System.test_type(value[0], String) then
              self._create_many(name, (
                value.map do |a|
                  Paths.parse(a).deref(@root);
                end
              ), keyed);
            else
              self[name].each do |obj|
                obj._complete;
              end
            end
          elsif System.test_type(value, String) then
            self.define_singleton_value(key, Paths.parse(value).deref(@root));
          else
            self[key]._complete;
          end
        end
      end
      @root.types.each do |cls|
        self.define_singleton_value(S(cls.name, "?"), @data["class"] == cls.name);
      end
    end

    def _create_many(name, arr, keyed)
      self.define_singleton_value(name, BootManyField.new(arr, @root, keyed));
    end
  end

  class Schema < MObject

    def classes
      BootManyField.new((
        self.types.select do |t|
          t.Class_P;
        end
      ), @root, true);
    end

    def primitives
      BootManyField.new((
        self.types.select do |t|
          t.Primitive_P;
        end
      ), @root, true);
    end
  end

  class Class < MObject

    def all_fields
      BootManyField.new((
        self.supers.flat_map do |s|
          s.all_fields;
        end
      ) + self.defined_fields, @root, true);
    end

    def fields
      BootManyField.new((
        self.all_fields.select do |f|
          ! f.computed;
        end
      ), @root, true);
    end
  end

  class BootManyField < Array

    def initialize(arr, root, keyed)
      arr.each do |obj|
        self.push(obj);
      end
      @root = root;
      @keyed = keyed;
    end

    def [](key)
      if @keyed then
        self.find do |obj|
          obj.name == key;
        end
      else
        self.at(key);
      end
    end

    def has_key_P(key)
      self[key];
    end

    def each_with_match(other, &block)
      local :other , :ks , :a , :b
      if @keyed then
        other = other || {};
        ks = self.keys || other.keys;
        ks.each do |k|
          block.call(self[k], other[k]);
        end
      else
        a = Array(self);
        b = Array(other);
        Range.new(0, [a.length, b.length].max - 1).each do |i|
          block.call(a[i], b[i]);
        end
      end
    end

    def keys
      if @keyed then
        self.map do |o|
          o.name;
        end
      else
        nil;
      end
    end
  end
end
