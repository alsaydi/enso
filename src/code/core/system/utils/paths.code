

module Paths
  @ parse = (
    do |str|
      p = Path.parse(str);
      p;
    end
  )

  @ new = (
    do |elts = []|
      Path.new(elts);
    end
  )

  class Path

    def self.parse(str)
      local :original , :str , :base , :elts
      original = str;
      str = str.gsub("\\\\", "");
      if str[0] == "/" then
        str = str.slice(1, 1000);
        base = [Root.new];
      else
        base = [];
      end
      elts = (base + self.scan(str)).flatten;
      Path.new(elts);
    end

    def self.scan(str)
      local :n , :base , :index
      str.split("/").map do |part|
        if part == "." then
          [];
        elsif (
          n = part.index("[");
        ) && part.slice(- 1) == "]" then
          base = part.slice(0, n);
          index = part.slice(n + 1, (part.length - n) - 2);
          [Field.new(base), Key.new(index)];
        else
          Field.new(part);
        end
      end
    end

    attr_reader :elts

    def initialize(elts = [])
      @elts = elts;
    end

    def reset_in_place
      @elts = [];
    end

    def prepend_in_place(path)
      @elts = path.elts + @elts;
    end

    def extend(path)
      Path.new(self.elts + path.elts);
    end

    def deref_P(scan, root = scan)
      local :root
      begin
        self.deref(scan, (
          root = scan;
        ));
      rescue
        false;
      end
    end

    def deref(scan, root = scan)
      local :scan
      self.elts.each do |elt|
        if ! scan then
          self.raise(S("cannot dereference ", elt, " on ", scan));
        end
        scan = elt.deref(scan, root);
      end
      scan;
    end

    def search(root, base, target)
      self.searchElts(self.elts, base, root, {}) do |item, bindings|
        if target.equals(item) then
          bindings;
        end
      end
    end

    def searchElts(todo, scan, root, bindings, &action)
      if todo.nil_P || todo.first.nil_P then
        action.call(scan, bindings);
      else
        todo.first.search(scan, root, bindings) do |item, newBinds|
          self.searchElts(todo[Range.new(1, - 1)], item, root, newBinds, &action);
        end
      end
    end

    def field(name)
      self.descend(Field.new(name));
    end

    def key(key)
      self.descend(Key.new(key));
    end

    def index(index)
      self.descend(Index.new(index));
    end

    def root_P
      self.elts.empty_P;
    end

    def lvalue_P
      ! self.root_P && self.last.is_a_P(Field);
    end

    def assign(root, obj)
      if ! self.lvalue_P then
        self.raise(S("Can only assign to lvalues not to ", self));
      end
      self.owner.deref(root)[self.last.name] = obj;
    end

    def assign_and_coerce(root, value)
      local :obj , :fld , :value
      if ! self.lvalue_P then
        self.raise(S("Can only assign to lvalues not to ", self));
      end
      obj = self.owner.deref(root);
      fld = obj.schema_class.fields[self.last.name];
      if fld.type.Primitive_P then
        value = if fld.type.name == "str" then
          value.to_s;
        elsif fld.type.name == "int" then
          value.to_i;
        elsif fld.type.name == "bool" then
          if value.to_s == "true" then
            true;
          else
            false;
          end
        elsif fld.type.name == "real" then
          value.to_f;
        else
          self.raise(S("Unknown primitive type: ", fld.type.name));
        end
      end
      self.owner.deref(root)[self.last.name] = value;
    end

    def insert(root, obj)
      self.deref(root).push(obj);
    end

    def insert_at(root, key, obj)
      self.deref(root)[key] = obj;
    end

    def owner
      Path.new(self.elts[Range.new(0, - 2)]);
    end

    def last
      self.elts.last;
    end

    def to_s
      local :res
      res = self.elts.join;
      if res == "" then
        "/";
      else
        res;
      end
    end

    def descend(elt)
      Path.new([elt]);
    end
  end

  class Elt

  end

  class Root < Elt

    def deref(obj, root)
      root;
    end

    def search(obj, root, bindings, &action)
      action.call(root, bindings);
    end

    def to_s
      "ROOT";
    end
  end

  class Field < Elt

    attr_reader :name

    def initialize(name)
      @name = name;
    end

    def deref(obj, root)
      obj[@name];
    end

    def search(obj, root, bindings, &action)
      if ! obj.nil_P && obj.schema_class.all_fields[@name] then
        action.call(obj[@name], bindings);
      end
    end

    def to_s
      S("/", @name);
    end
  end

  class Index < Elt

    attr_reader :index

    def initialize(index)
      @index = index;
    end

    def deref(obj, root)
      obj[@index];
    end

    def search(obj, root, bindings, &action)
      if @index.is_a_P(PathVar) then
        obj.find_first_with_index do |item, i|
          action.call(item, {}.update(bindings));
        end
      else
        action.call(obj[@index], bindings);
      end
    end

    def to_s
      S("[", @index, "]");
    end
  end

  class Key < Elt

    attr_reader :key

    def initialize(key)
      @key = key;
    end

    def deref(obj, root)
      obj[@key];
    end

    def search(obj, root, bindings, &action)
      if @key.is_a_P(PathVar) then
        obj.find_first_pair do |k, item|
          action.call(item, {}.update(bindings));
        end
      else
        action.call(obj[@key], bindings);
      end
    end

    def to_s
      S("[", self.escape(@key.to_s), "]");
    end

    def escape(s)
      s.gsub("]", "\\\\]").gsub("[", "\\\\[");
    end
  end

  class PathVar

    def initialize(name)
      @name = name;
    end

    attr_reader :name

    def to_s
      @name;
    end
  end
end
