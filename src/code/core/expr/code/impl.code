require "core/expr/code/eval" # Eval
require "core/expr/code/lvalue" # Lvalue
require "core/semantics/code/interpreter" # Interpreter

module Impl
  class Closure

    attr_accessor :env

    def initialize(body, formals, env, interp)
      @body = body;
      @formals = formals;
      @env = env.clone;
      @interp = interp;
    end

    def call(*params)
      local :nenv
      nenv = Env.HashEnv.new;
      @formals.zip(params).each do |f, v|
        nenv[f.name] = v;
      end
      nenv.set_parent(@env);
      @interp.dynamic_bind({}) do
        @interp.eval(@body);
      end
    end

    def to_s
      S("#<Closure(", (
        @formals.map do |f|
          f.name;
        end
      ).join(", "), ") {", @body, "}>");
    end
  end

  module EvalCommand
    include Eval. EvalExpr
    include Lvalue. LValueExpr
    include Interpreter. Dispatcher

    def eval(obj)
      self.dispatch("eval", obj);
    end

    def eval_EWhile(cond, body)
      while self.eval(cond) do
        self.eval(body);
      end
    end

    def eval_EFor(var_V, list, body)
      local :nenv
      nenv = Env.HashEnv.new.set_parent(@D["env"]);
      self.eval(list).each do |val|
        nenv[var_V] = val;
        self.dynamic_bind({}) do
          self.eval(body);
        end
      end
    end

    def eval_EIf(cond, body, body2)
      if self.eval(cond) then
        self.eval(body);
      elsif ! (body2 == nil) then
        self.eval(body2);
      end
    end

    def eval_EBlock(body)
      local :res
      res = nil;
      self.dynamic_bind({}) do
        body.each do |c|
          res = self.eval(c);
        end
      end
      res;
    end

    def eval_EFunDef(name, formals, body)
      local :res
      res = Impl.Closure.new(body, formals, @D["env"], self);
      res.env[name] = res;
      @D["env"][name] = res;
      res;
    end

    def eval_ELambda(body, formals)
      Proc.new do |*p|
        Impl.Closure.new(body, formals, @D["env"], self).call(*p);
      end
    end

    def eval_EFunCall(fun, params, lambda)
      local :p , :f
      self.dynamic_bind({}) do
        if lambda == nil then
          self.eval(fun).call(*(
            params.map do |p|
              self.eval(p);
            end
          ));
        else
          p = self.eval(lambda);
          f = self.eval(fun);
          f.call(*(
            params.map do |p|
              self.eval(p);
            end
          ), &p);
        end
      end
    end

    def eval_EAssign(var_V, val)
      self.lvalue(var_V).value = self.eval(val);
    end
  end

  class EvalCommandC
    include EvalCommand

    def initialize
    end
  end
end
