require "core/schema/code/factory" # Factory
require "core/system/library/schema" # Schema
require "core/semantics/code/interpreter" # Interpreter

module Eval
  module EvalExpr
    include Interpreter. Dispatcher

    def eval(obj)
      self.dispatch("eval", obj);
    end

    def eval_ETernOp(op1, op2, e1, e2, e3)
      if self.eval(e1) then
        self.eval(e2);
      else
        self.eval(e3);
      end
    end

    def eval_EBinOp(op, e1, e2)
      if op == "&" then
        self.eval(e1) && self.eval(e2);
      elsif op == "|" then
        self.eval(e1) || self.eval(e2);
      else
        self.eval(e1).send(op.to_s, self.eval(e2));
      end
    end

    def eval_EUnOp(op, e)
      self.eval(e).send(op.to_s);
    end

    def eval_EVar(name)
      if ! @D["env"].has_key_P(name) then
        self.raise(S("ERROR: undefined variable ", name));
      end
      @D["env"][name];
    end

    def eval_ESubscript(e, sub)
      self.eval(e)[self.eval(sub)];
    end

    def eval_EConst(val)
      val;
    end

    def eval_ENil
      nil;
    end

    def eval_EFunCall(fun, params)
      self.dynamic_bind({}) do
        self.eval(fun).call(*(
          params.map do |p|
            self.eval(p);
          end
        ));
      end
    end

    def eval_EList(elems)
      local :k , :r
      k = Schema.class_key(@D["for_field"].type);
      if k then
        r = ManagedData.Set.new(nil, nil, k);
      else
        r = ManagedData.List.new(nil, nil);
      end
      elems.each do |elem|
        r.push(self.eval(elem));
      end
      r;
    end

    def eval_EField(e, fname)
      local :target
      if @D["in_fc"] then
        self.dynamic_bind({}) do
          target = self.eval(e);
          target.method(fname.to_sym);
        end
      else
        self.eval(e).send(fname);
      end
    end
  end

  class EvalExprC
    include EvalExpr

    def initialize
    end
  end
end
