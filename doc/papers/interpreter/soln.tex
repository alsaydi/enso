\comments{
Contributions of this work:
- Composition
  - adding new data types and operations
- Cross-cutting modifications
  - operation inheritance
    - compound operation composition (of which inheritance is special case)
- Meta-level
  - Schema and grammar as well 
- Feature-oriented 'packaging' -> gotta give this a better name

How we do it:
- s

}

\section{Extensible Interpreters for DSLs}

Our approach enforce the rigor of a formal specification on hand-written code. \Enso interpreters are written as Ruby mixins following a specific convention, this allows them to make full use of the mature language feature set in Ruby. 

\begin{enumerate}
\item x
\item y
\end{enumerate}


\comments{
\subsection{Adding new data types and operations}
(i'm not going to let this guy get his own subsection
- interpreters defined as visitor mixins
  - simple dispatch system based on data type
    - has subtype polymorphism and a 'root' type <-- i dont know what to call this
- well-known concept that allows extension of ...

- internal visitor enforce composability
  - internal visitors are produced via composition

- 
}

The core of the interpreter framework in \Enso is 

\subsubsection{Cross-cutting extensions}

\comments{
  
}

\subsection{Interpreter composition}

\comments{

}

\subsubsection{Higher-order interpreter composition}

\subsection{Meta-level language extensions}

\subsection{Cross-model language features}

\comments{
- features
  - define "features"
- package different types of artefacts together
- because of meta-level this can be used both for dsl dev as well as dsl
}

\subsection{Tooling for extensible DSLs}





