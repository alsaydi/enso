Composable interpreters for language-oriented programming

* abstract

* introduction
- background
  - DSLs are ...
    - definition
    - advantages
    - examples
  - language oriented programming is ...
    - paradigm of using DSLs as primary artefact of 
      program organization
    - briefly embrace related tools
      - model-driven engineering
      - grammarware (? needs better definition)
  - practical use of LOP -- s/w engr issues?
    <This is the problem statement>
    - reuse
    - analysis / tooling
      - tool generation from DSL definiton
      - new paradigms required?
    - integrating multiple DSLs
      - integrity validation
      - cross-cutting integration
  (cite France/Rumpe's paper here, claiming analog with MDE)
- evolution scenario
  - language change always have big reprecussions
    how do you minimize this?
- syntactic and semantic composition
  - briefly lay out how others fall short in semantic compo

* motivating example: ensoweb
  - multiple languages:
    - model driven design
    - web ui language
    - database language
    - security policy language
  - interactions:
    - reuse: eg expressions
    - crosscutting interactions
    - refinement: eg secure vs non-secure
- what are we trying to achieve
  <the solution statement>
  - integrate multiple DSLs at both semantic and 
    syntactic levels

* related work (and where they fall short)
- standalone interpreters (code)
- embedded dsls
- translators

* our soln (overview)
- contributions of this work are:
  - BLAH
  - BLAG
  - BLEU
  - Helps me graduate if you accept my paper
- Based on interpreter pattern
  - Interpreters as mixins
  - Extensibility both when adding new nodes 
    and adding new operations
- Dispatch
  - generic / subtype polymorphic lookup
  - parameters passed as dictionaries
  - multi-dispatch?
- Composable
  - Horizontal: adding operations and types modularly
  - Vertical: mixin inheritance
  - Integrity is enforced by external (type-) checker
    - structural subtyping
    - subtype relation between interpreter and schema
- Reuse
  - sub-language consistent across different DSLs
  - slight variations tolerated (eg web expressions)
  - cyclic dependencies



* why interpreters
- the argument for interpreters
  - less indirection: better runtime analysis, etc
  - reuse library code from implementation language
  - more 'natural' (subjective)
  - partial evaluation (is this an advantage or the
    mitigation of a disadvantage?)
- disadvantages of interpreters (compared to?)
  - blackbox -- hard to analyze, generate tools, etc
  - reusability
  - difficult to design language from scratch (cf ??)

* our solution
- Based on interpreter pattern
  - Interpreters as mixins
  - Extensibility both when adding new nodes 
    and adding new operations
- Reuse
  - slight variations tolerated (eg web expressions)
  - cyclic dependencies
  - sub-language consistent across different DSLs
- Dispatch
  - generic / subtype polymorphic lookup
  - parameters passed as dictionaries
  - multi-dispatch?
- Composable
  - Horizontal: adding operations and types modularly
  - Vertical: mixin inheritance
  - Integrity is enforced by external (type-) checker
    - structural subtyping
    - subtype relation between interpreter and schema


- Combinators
  - interpreters as code
  - combinators
  - fmap, internal

- Cyclic dependencies
  - eg main language elements used in expressions

- Implementation
  - Open classes
  - Mixin inheritance

* other things
- Generics
  - Interpreter can be used for multiple similar models
  - Type checking interpreters against models

* conclusions


