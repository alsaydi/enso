\comments{


Problem(s):
- Writing DSLs is hard
 - time/manpower cost
 - devs need new lang engr skills
 - incremental adoption
- Why?
>>>
 1. you can either do it as code
 - if it's code
   - difficult to reuse -> hidden/implicit dependencies
   - difficult to automatically analyze
     - generating model-independent tooling
   - interactions between models
 2. or as formal blahs
 - eg state machines [?], uml statecharts [statemate?], attribute grammars [Lisa?], tranformation rules? this is almost like small-step semantics [ATL]
 - if it's formal blahs
   - do not automatically come with all the p/l toys we are used to: generics, arrays, ?
     - we can program them in, but it'll be reinventing wheel
   - tricky to connect to existing libraries




Problem: Engineering DSLs is hard
- requires a different degree of reuse than normal code
- challenges include:
  - unanticipated change [van Deursen98] -> spin this as 
    "we want to support dsl evolution" rather than the 
    whole co-evolution businness
  - many-dsl interaction, etc etc [France01]
  - reuse not good from empirical study [hermans09], 
    but it's model reuse, not language/metamodel reuse
- default solns (ie writing code) not good, because:
  - ?

problems:
- initial cost of developing dsls
  - time and manpower
  - shift in required skill set [vanDeursen98]
- sustained cost of maintenance
  - system requirements changes
  - role of dsl expand into new products, new features
- dsl interaction
  - enforce referential integrity between related concepts


so far:
- relatively successful at integrating models
  - emf, model weaving
  - extensible parsing techniques
- semantics, not so successful
  - ways of defining operational semantics for 
  - code generators
  - 
}

\section{Introduction}

Domain specific languages (DSLs) are languages specialized for a particular problem domain. A set of specialists, known as /toolsmiths/, first construct DSLs encapsulating the relevant domain knowledge, which application programmers can then use to build specific applications. Examples of DSLs include SQL for database management, Yacc for text parsing, and Verilog for hardware description, among many others. DSLs allow application programmers to work with a vocabulary and language structure similar to that of the domain expert, thus reducing the syntactic misalignment between problem definition and solution specification. Language-oriented programming [Ward94] is a software engieering paradigm which systematically deploys DSLs as the primary artefact of program organization, allowing domain knowledge to be remain encapsulated across traditional module boundaries of of classes and functions. Model driven engineering [OMG01] is a variation on the same concept that substitutes concrete textual DSLs with /models/ of their abstract represention.

Unfortunately DSL development is not easy. On top of the additional one-time cost over directly implementing the application, DSL development also necessitate a shift in programmer skill sets [vanDeursen98] to include both learning the relevant tools and mastering the patterns of good language design [Spinelli01]. Moreover, even though one of the goal of DSLs as an "enabler of reuse" [Mernik05], the added range of artefacts from grammars to interpreters to tooling, and their often monolithic nature, ironically hinders reuse in the development of the DSLs themselves. DSLs evolve more often...

<evolve \cite mernik05 and say responsibility change. tolerate slght diffs>

Finally, <incremental deployment>

<something about formal methods>
<and why they suck>

The general software engineering problems of encapsulation, reuse, cross-cutting concerns and incremental integration of DSLs are not new [Mernik04Incremental, Wagelaar11m2mx] and typically the approach has been to augment the formal method with 







The other major cost comes from maintainence. Like other software systems, DSLs are seldom static and evolve according to requirement changes. Even if the domain logic remains constant, the DSL's responsibility might increase over time as it becomes used more widely [?]. The robustness challenge for DSL developers here is to tolerate slight variations across versions, including building checkers to determine if the particular variation is allowed. In the ideal case, a DSL may also be refined modularly, such that any combination of variants can be selected without an exponential increase in code.

One of the key enablers of .... is extensible .... 
current dsl workbenches often  leave ... largely as an exercise to the programmer



In this paper, we describe a system for building extensible interpreters in our language workbench \Enso. 





The rest of the paper is organized as follows: in \ref{sec:example} we introduce our motivating example and identify the reuse problems we are trying to solve, in \ref{sec:enso} we briefly introduce \Enso, our domain-specific language workbench, followed by \ref{sec:soln} that describes our proposed solution, finally in \ref{sec:related} we review related work and conlude in \ref{sec:conclusion}.

>>>>>>>>>>>>>>>>>>>>>>>


One of the key promises of DSLs is high-level semantic analysis by allowing the programmer to specify the program, with minimal accidental complexities, using a  language and vocabulary close to the problem definition. In order to preserve the high-level semantics and make their behavior easier to reason about, DSL tools designers often turn to formal methods like 



>>>>>>>>>>>>>>>>>>>>>>

DSL designers not only have to define models, they also need to specify how these models behave. There are a several accepted ways of doing this: 




