\documentclass[11pt]{article}
\usepackage{geometry}                % See geometry.pdf to learn the layout options. There are lots.
\geometry{letterpaper}                   % ... or a4paper or a5paper or ... 
%\geometry{landscape}                % Activate for for rotated page geometry
%\usepackage[parfill]{parskip}    % Activate to begin paragraphs with an empty line rather than an indent
\usepackage[pdftex]{graphicx}
\usepackage{amssymb}
\usepackage{epstopdf}
\usepackage{xspace}
\usepackage{amsthm}

\usepackage[T1]{fontenc}
\usepackage[scaled=0.8]{beramono}

%\DeclareGraphicsRule{.tif}{png}{.png}{`convert #1 `dirname #1`/`basename #1 .tif`.png}
\usepackage{listings} 

\lstset{%
  numbers=none,
  sensitive=true,
  morecomment=[l]{//},
  morecomment=[s]{/*}{*/},
  morestring=[b]",
  emphstyle={\bf},
  commentstyle=\it,
  stringstyle=\mdseries\ttfamily,
  showspaces=false,
  basicstyle=\ttfamily,
  morekeywords={schema,type},
  keywordstyle=\bfseries,
  columns=flexible,
  showstringspaces=false,
  morecomment=[l]\%,
}

\lstdefinelanguage{Schema}{%
  numbers=none,
  sensitive=true,
  morecomment=[l]{//},
  morecomment=[s]{/*}{*/},
  morestring=[b]",
  emphstyle={\bf},
  commentstyle=\it,
  stringstyle=\mdseries\ttfamily,
  showspaces=false,
  basicstyle=\ttfamily,
  morekeywords={class,end},
  keywordstyle=\bfseries,
  columns=flexible,
  showstringspaces=false,
  morecomment=[l]\%,
}


\lstdefinelanguage{Grammar}{%
  numbers=none,
  sensitive=true,
  morecomment=[l]{//},
  morecomment=[s]{/*}{*/},
  morestring=[b]",
  emphstyle={\bf},
  commentstyle=\it,
  stringstyle=\mdseries\ttfamily,
  showspaces=false,
  basicstyle=\ttfamily,
  morekeywords={start},
  keywordstyle=\bfseries,
  columns=flexible,
  showstringspaces=false,
  morecomment=[l]\%,
}


\newtheorem*{ex}{TEST}

\newcommand{\C}{\lstinline}
\newcommand{\comments}[1]{} 

\lstset{language=Ruby}

\def\Enso{Ens\={o}\xspace}

\title{\includegraphics[scale=0.25]{enso.jpg}\\ Piping \& Instrumentation in \Enso \\
   Language Workbench Challenge 2012}
\author{Alex Loh, William R. Cook, Tijs van der Storm}

\begin{document}
\maketitle

\begin{abstract}

\end{abstract}

\section{Introduction}

The 2$^{nd}$ Language Workbench Challenge (LWC2012) takes place on the 27$^{th}$ of March 2012 in Cambridge, UK. The purpose of this challenge was to faciliate the exchange of ideas between various groups building Domain-Specific Language (DSL) development tools. Our language workbench, \Enso, will be showcased together with nine other tools from both academic and commercial organizations.

\subsection{The Challenge}

The challenge component of LWC2012 is to design and implement a language for controlling a central water heating system. There are two main parts to the assignment: 1) a controller language that sends out low-level instructions to the heating and piping system, and 2) a piping simulator that can mimic a real heating system for offline testing.

A boiler example described in the challenge consists of a boiler and a radiator connected in parallel to a pump and heater. The pump pushes hot water to a valve, which is then channelled by a valve either towards just boiler or radiator or both. The 

<INSERT PICTURE>

\section{\Enso: A self-describing DSL workbench}

\comments{
- Key characteristics
  - Self-describing
    - 'everything is a language' (don't say this; say "language-oriented programming")
    - dsl tools can be used at both levels
    - auto-bootstrapped from meta-metamodel
      - metametamodel can be changed (even dynamically)
  - Interpreter vs code generation
    - avoid one level of indirection to: 
      - sidestep round-tripping issues
      - easier to build tools (correctness,  that depend on the run-time
  - Decouple editing from internal representation
    - representation freedom
- Key weakness
  - no IDE
    - leverage Ruby's debugging capabilities
}

\Enso is an external language workbench with both graphical and textual editing capabilities. Each language is defined by a \emph{schema}, or the model of its internal representation, which can be rendered either textually via a grammar or graphically via the diagramming DSL, \emph{stencil}. Behavioral semantics in \Enso are defined using model interpreters written in the Ruby programming language. Using model interpreters avoids the additional layer of indirection introduced by code generators, without round-trip engineering, and maintains the semantic link between model and behavior for dynamic tools such as debuggers and profilers to operate at the model level. Writing interpreters with general purpose code, as opposed to more formal methods like statecharts or transformation rules, provides toolsmiths unfettered access the full range of features found in modern programming languages, such as generics, object-oriented inheritance, and higher-order constructs, without re-inventing the wheel.

Internally, \Enso executes on top of itself: the various components of the workbench, including the schema, grammar and stencil languages, are implemented as a stack of self-describing \Enso DSLs. The schema of the schema language in particular closely mirrors the meta-metamodel of Meta-Object Facility (MOF). However, unlike most MDE tools, \Enso's schema-schema is not hardcoded and can be modified, even dynamically, to extend the workbench itself. The conceptually elegant self-reflection also has the practical advantage of allowing application developers, toolsmiths, and even \Enso extension builders to share the same toolchain. 

<<QUAD MODEL PIC>>

The other key strength of \Enso is strong support for language reuse. DSLs can be composed, extended or wrapped via inheritance, either directly or in a cross-cutting manner, enabling powerful reuse of its language library. Generic template languages, such as the command language, are routinely extended to served as the backbone for a family of languages.

The name "\Enso" originates from Japanese Zen philosophy and is associated with the ideas of “absolute enlightenment, strength, elegance, the universe, and the void.” Its symbol is that of a circle, which in our context embodies the self-describing nature and cyclic object graphs of our tool.

The full implementation of \Enso is available from http://github place.

\subsection{Our solution}

The piping language is used to describe a Piping and Instrumentation Diagram (P\&ID). A P\&ID is a network of \emph{elements}, such as burners, pumps, and radiators, connected by pipes of varying length and diameter. Additionally, sensors may be attached to elements and pipes to measure temperature, flow rate or pressure. In our system, pipe connections such as joints and environment exhausts, as well as controllable valves, are also considered elements.

These languages interact through a narrow API that simulates how 
----With \Enso, we need to define a \emph{schema} model for each of these DSLs and both textual and graphical for them.

The rest of this report will list and explain the model and code used in the construction of the P\&ID system. Section \ref{sec:models} lists the model definitions for the piping and controller langugages. Section \ref{sec:interpreter} briefly discusses the behavior of the languages according to their interpreters. Section \ref{sec:stencil} will describe the stencil language, a novel contribution of \Enso, and how it is used in this work. Finally, Section \ref{sec:conclusion} will conclude this report with a summary of the statistics (SLOC, dev time, reused) of our P\&ID system.

\section{Model Languages}

\subsection{Piping Language}

The piping language describes the configuration of pipes and heating elements in the system. Figure \ref{} lists the schema of the piping language and Figure \ref{} lists its corresponding grammar. The schema language is fairly 

\begin{figure}
\lstinputlisting[linerange=2-28,language=Schema]{../../../src/applications/Piping/models/piping.schema} % APPLY:linerange=PIPING_SCHEMA_ONE
\caption{Schema of the Piping language (Part One)}
\label{piping-grammar}
\end{figure}
\begin{figure}
\lstinputlisting[linerange=32-75,language=Schema]{../../../src/applications/Piping/models/piping.schema} % APPLY:linerange=PIPING_SCHEMA_TWO
\caption{Schema of the Piping language (Part Two)}
\label{piping-grammar}
\end{figure}

\begin{figure}
\lstinputlisting[language=Grammar]{../../../src/applications/Piping/models/piping.grammar} % APPLY:linerange=PROG
\caption{Grammar of the Piping language}
\label{piping-grammar}
\end{figure}

In the boiler example

\begin{figure}
\lstinputlisting[language=Grammar]{../../../src/applications/Piping/models/controller.stencil} % APPLY:linerange=PROG
\caption{Boiler controller}
\label{boiler-controller}
\end{figure}

\subsection{Controller Language}

The controller language is structured as a finite state machine. Each state has conditions that trigger a state transition and some actions to take while in that state.

\begin{figure}
\lstinputlisting[linerange=2-28,language=Schema]{../../../src/applications/Piping/models/controller.schema} % APPLY:linerange=PIPING_SCHEMA_ONE
\caption{Schema of the Controller language (Part One)}
\label{controller-grammar}
\end{figure}

\begin{figure}
\lstinputlisting[language=Grammar]{../../../src/applications/Piping/models/controller.grammar} % APPLY:linerange=PROG
\caption{Grammar of the Controller language}
\label{controller-grammar}
\end{figure}

In the boiler example, we have three states

\begin{figure}
\lstinputlisting[language=Grammar]{../../../src/applications/Piping/models/controller.stencil} % APPLY:linerange=PROG
\caption{Boiler controller}
\label{boiler-controller}
\end{figure}

\section{Execution}

\subsection{Controller Interpreter}



\subsection{Piping Simulation}

Flow simulation is based on simplified laminar fluid flow and pressure laws:

\[
Flow \propto \frac{\Delta Pressure}{\Delta Distance}
\]

Assuming that pressure difference is linear within a pipe, and that the total flow in and out of a point is constant, we can derive that for any element E, the sum of ratio between the pressure difference at the two ends of a pipe and its length for all pipes leading away from P is zero. 

\[
\sum_{i=pipe.0}^{pipe.n}{ (Pressure_{i}-Pressure_{E}) / Length_{i} } = 0 
\textrm{where Pressure_{i} is the pressure at the end of pipe_{i} not connected to E}
\]

These laws hold for all elements and joints except those that disrupt flow in some way, for instance, open ends assigns a fixed value to pressure (based on environmental values) and a closed valve forces the pressure at both ends of a pipe to be the same. Likewise, pumps set the pressure at its output end to a fixed value. The pressure simulator applies these laws iteratively at every element and joint until a fixpoint is reached. This produces a pressure map of the system, with absolute values at each element and pressure assumed to decrease linearly within each pipe. Using this pressure map we can then calculate the flow in each individual pipe.

\[
Flow_{p}\textrm{, the flow through pipe p} = Flow_{Pump} * \frac{\Delta Pressure_{p}}{\Delta Distance_{p}} / \frac{\Delta Pressure_{Pump}}{\Delta Distance_{Pump}}
\]

Heat transfer can take place between a suitable element, such as a vessel, and the pipe it is attached to. The rate is based on the difference between their temperatures. Likewise, heat transfer can occur between water in a pipe and the environment, resulting in heat dissipation. Again, the rate of this dissapation is based on the temperature difference between the water and the environment. Room temperature is hardcoded in the simulator to 10$^\circ$ Celsius, or 50$^\circ$ Fahrenheit.

\section{Graphical Rendering with Stencils}


\subsection{Editing}


\begin{figure}
\lstinputlisting[language=Grammar]{../../../src/applications/Piping/models/piping.stencil} % APPLY:linerange=PROG
\caption{Stencil of the Piping language}
\label{piping-stencil}
\end{figure}

\begin{figure}
\lstinputlisting[language=Grammar]{../../../src/applications/Piping/models/controller.stencil} % APPLY:linerange=PROG
\caption{Stencil of the Controller language}
\label{controller-stencil}
\end{figure}

\subsection{Animation}

Animation is piggybacked on top of the editor.

\section{Conclusion}

\comments{
- SLOC
- Dev time
- 
}

The piping and controller DSLs each comprises its schema, a grammar for textual editing, a stencil for graphical editing and its interpreter. The entire P\&ID system was developed with xxx lines of model code and xxx lines of Ruby code. The boiler example was created using this P\&ID system using xxx lines of model code.

\end{document}  


