\documentclass[preprint,10pt]{sigplanconf}
\usepackage{authblk,xspace, amsmath, amssymb, subfigure}
\usepackage{stmaryrd,algorithm}
\usepackage{enso}
\usepackage[noend]{algpseudocode}
\begin{document}
\conferenceinfo{Something'12}{Somewhere}
\copyrightyear{2012}
\titlebanner{DRAFT---do not distribute}
\preprintfooter{Enso grammars}

\title{Information Grammars} % Schema Grammars

\authorinfo{William R. Cook}%
{University of Texas at Austin}%
{wcook@cs.utexas.edu}

\authorinfo{Tijs van der Storm}%
{Centrum Wiskunde \&\ Informatica (CWI)}%
{storm@cwi.nl}
\maketitle

\begin{abstract}
<<<<<<< HEAD
  \enso is a programming environment based on interpretation of
  domain-specific languages (DSLs). The abstract syntax of a DSL is
  represented as an object-oriented information model. We present a
  detailed description of \enso grammars, which are used to serialize
  and deserialize such models to and from textual representation.
=======
  \enso is a programming system based on definition, interpretation, and composition of
  domain-specific languages (DSLs). In \enso, the problem of parsing and pretty-printing
  is viewed as a potentially complex mapping between abstract models and textual presentations.
  \enso grammars enable both parsing and printing by specifying both the abstract model
  structure and the textual presentation declaratively. The system supports automatic
  resolution of names to handle cases where the abstract model is a graph, but the 
  text presentation uses names to connect concepts. Predicates on the abstract model 
  can be used to provide additional control over the mapping. The \enso parser handles arbitrary
  context-free grammars, which facilitates composition of grammars. 
  Finally, we show how grammars can be checked statically for consistency with the
  corresponding abstract model structure.
>>>>>>> 0c168ceb6911dbd549060dffe329eb908c01c9d1
\end{abstract}

\category{D.x.y}{Programming Languages}{To be done}

\terms
Domain-specific languages, Language-oriented programming

\keywords
Grammar, parsing, schema


\section{Introduction}

``Killer'' example

\begin{figure}
\begin{minipage}[t]{0.5\linewidth}
\begin{lstlisting}[language=ensoschema]
primitive str

class Machine
  start: State
! states: State*

class State
  machine: Machine
  name: str
  out: Transition*
  in: Transition*
\end{lstlisting}
\end{minipage}
\begin{minipage}[t]{0.4\linewidth}
\begin{lstlisting}[language=ensoschema]
class Transition
  event: str
  from: State
  to: State
  action: str
\end{lstlisting}
\end{minipage}
\caption{Schema describing state machines}
\end{figure}

\begin{figure}
\begin{lstlisting}[language=ensogrammar]
start Machine
Machine ::= [Machine] "start" 
               \start:/states[it]^ 
               states:State*
State ::= [State] "state" name:sym 
               out:Transition*
Transition ::= [Transition] "on" event:sym 
               "go" to:/states[it]^
\end{lstlisting}
\caption{Grammar to (de)serialize state machines}
\end{figure}

\begin{figure}
\begin{minipage}[t]{0.5\linewidth}
\begin{lstlisting}[language=ensostm]
start Opened
state Opened
  on close go Closed
state Closed
  on open go Opened
  on lock go Locked
\end{lstlisting}
\end{minipage}
\begin{minipage}[t]{0.4\linewidth}
\begin{lstlisting}[language=ensostm]
state Locked
  on unlock go Closed
\end{lstlisting}
\end{minipage}
\caption{Textual rendering of a state machine}
\end{figure}

\paragraph{Contributions}

\begin{itemize}
\item \ensogrammars for (de)serializing arbitrary graphs that
  are typed by a class-based schema.
\item Bi-directional semantics for cross links and semantic actions.
\item Type checking procedure to ensure that a grammar and schema are
  compatible (bi-directional?).
\item A simple but powerful parsing method based on grammar
  interpretation, using the GLL algorithm.
\item A rendering algorithm based on Wadler's prettier printer to
  transform a model to text, again through grammar interpretation.
\end{itemize}

\section{Design}

\input{design}

\section{Meta Syntax}

\def\literal#1{\ensuremath{\text{\texttt{"}}#1\text{\texttt{"}}}}

\begin{figure}
\[
\begin{array}{rcll}
S & ::= & \varepsilon & \text{(Empty)} \\
  & \mid & t & \text{(Token; } t\in\{\text{\texttt{str}}, \text{\texttt{int}}, \text{\texttt{sym}}, \literal{s},... \}\text{)} \\
  & \mid & N & \text{(Non-terminal)}\\
  & \mid & P\Uparrow & \text{(Reference)}\\
  & \mid & S\;\oplus & \text{(Regular; }\oplus\in\{?,*,+\}\text{)}\\ 
  & \mid & f:S & \text{(Field)}\\
  & \mid & S\cdot S & \text{(Sequence)}\\
  & \mid & [C]\; S & \text{(Create)}\\
  & \mid & S \mid S & \text{(Alternative)}\\
\end{array}
\]
\caption{Abstract syntax of \enso grammars\label{FIG:metasyntax}}
\end{figure}


\begin{figure}
\[
\begin{array}{rcll}
P & ::= & \varepsilon & \text{(Root)}\\
  & \mid & . & \text{(Current)}\\
%  & \mid & .. & \text{(Parent)}\\
  & \mid & P / f & \text{(Field)}\\
  & \mid & P [c] & \text{(Constant subscript)}\\
  & \mid & P [P] & \text{(Path subscript)}\\
\end{array}
\]
\caption{Abstract syntax of paths\label{FIG:pathsyntax}}
\end{figure}

\begin{figure}
\[
\begin{array}{rcll}
T & ::=  &\varepsilon & \text{(Empty)}\\
  & \mid & t: s & \text{(Token)}\\
  & \mid & \text{appl}(S, \overline{T}) & \text{(Application)}\\
\end{array}
\]
\caption{Syntax of derivation trees $T$\label{FIG:derivation}}
\end{figure}











\algblockdefx[Case]{Case}{EndCase}[1]{\textbf{case}\  #1\ \textbf{of}}[0]{\textbf{end case}}
\algcblockdefx[Case]{Case}{When}{EndCase}[1]{\textbf{when}\  #1:}[0]{\textbf{end case}}
\algcblockdefx[Case]{Case}{Else}{EndCase}[0]{\textbf{else}}[0]{\textbf{end case}}
%\algcblock{Switch}{Case}{Esac}
Build

\begin{algorithm}
\begin{center}
%\begin{minipage}{0.7\textwidth}
\begin{algorithmic}[1]
\Function{instantiate}{$v: V$, $S: Schema$}
  \Procedure{update}{$o: S$, $f_S: Field$, $x: S$}
    \State $o'[f_S.name] \ll x$ 
  \EndProcedure
  \State $fixups \gets \{\}$
  \Function{build}{$v: V$, $o: S$, $f_S: Field$}
    \Case{$v$}
    \When{$\llbracket C\rrbracket(\overline{B})$} 
        $o'\gets \text{\textbf{new }}S.classes[C]$
       \ForAll{$f:\overline{V}\in \overline{B}$, $v\in \overline{V}$}
          \State $f_S \gets S.classes[C].fields[f]$
          \State \Call{update}{$o'$, $f_S$, \textsc{build}($v$, $o'$, $f_S$)}
       \EndFor
       \State \Return{$o'$}
    \When{$P$}
        $fixups \ll \langle o, f_S, P\rangle$
       \State \Return{$\bot$}
    \Else
       \ \Return{}\Call{valueOf}{$v$, $f_S.type$}
    \EndCase
  \EndFunction
  \State $o \gets$ \Call{build}{$v$, $\bot$, $\bot$}
  \ForAll{$\langle o', f_S, P\rangle\in \Call{tsort}{fixups}$}
    \State \Call{update}{$o'$, $f_S$, \textsc{deref}($o$, $o'$, $P$)}
  \EndFor
  \State \Return{$o$}
\EndFunction
\end{algorithmic}
%\end{minipage}
\end{center}
\caption{Instantiation algorithm\label{ALG:instantiate}}
\end{algorithm}

\section{Type checking}

\[
\mathcal{L}(G) = \{ \tau\in T \mid start(G) \Rightarrow^* \tau \}
\]

The goal of type checking is something like

\[
typecheck(G, S) \implies \forall \tau \in \mathcal{L}(G): 
instantiate(\tau, S) \in S
\]
[Need to be expressed in terms of derivations, an non-ambiguity]


\def\myjoin{\ensuremath{\mid}}
\def\mymeet{\ensuremath{\cdot}}

\begin{table}[ht]
\footnotesize
\centering
\subfigure[Definition of \myjoin]{
% table for join (+)
\begin{tabular}{|c||c|c|c|c|c|}\hline
$\mid$ & $0$ & $1$ & $?$ & $*$ & $+$ \\\hline\hline
$0$ & $0$ & $?$ & $?$ & $*$ & $*$ \\\hline
$1$ & $?$ & $1$ & $?$ & $*$ & $+$ \\\hline
$?$ & $?$ & $?$ & $?$ & $*$ & $*$ \\\hline
$*$ & $*$ & $*$ & $*$ & $*$ & $*$ \\\hline
$+$ & $*$ & $+$ & $*$ & $*$ & $+$ \\\hline
\end{tabular}
\label{TBL:multJoin}
}
\subfigure[Definition of \mymeet]{
% table for meet (*)
\begin{tabular}{|c||c|c|c|c|c|}\hline
$\cdot$ & $0$ & $1$ & $?$ & $*$ & $+$ \\\hline\hline
$0$ & $0$ & $1$ & $?$ & $*$ & $+$ \\\hline
$1$ & $1$ & $+$ & $+$ & $+$ & $+$ \\\hline
$?$ & $?$ & $+$ & $*$ & $*$ & $+$ \\\hline
$*$ & $*$ & $+$ & $*$ & $*$ & $+$ \\\hline
$+$ & $+$ & $+$ & $+$ & $+$ & $+$ \\\hline
\end{tabular}
\label{TBL:multMeet}
}
\subfigure[Regular operators]{
\def\mystar{*}
\begin{tabular}{|c||c|c|c|}\hline
$x$ & $x^?$ & $x^*$ & $x^+$\\\hline\hline
$0$ & 0 & 0 & 0 \\\hline  
$1$ & ? & * & + \\  \hline
$?$ & ? & * & * \\  \hline
$*$ & * & * & * \\  \hline
$+$ & * & * & + \\  \hline
\end{tabular}
\label{TBL:multRegular}
}

\caption{Algebra of multiplicities\label{TBL:multAlgebra}}
\end{table}





\def\fixpoint{\ensuremath{\text{lfp}}}
\def\reachability{\ensuremath{\mathcal{R}}}
\begin{figure}
\begin{align*}
\reachability_C(A \circ B) &= \reachability_C(A) \cup \reachability_C(B)
 \text{ where } \circ \in \{\mid, \cdot\}\\
\reachability_C(A\;\oplus) &= \reachability(A) \text{ where } \oplus \in \{?, *, +\}\\
\reachability_C(N) &= \reachability_C(\alpha) \text{ where }N ::= \alpha\\
\reachability_C(f: A) &= \{\langle C, f\rangle\} \cup \reachability_C(A)\\
\reachability_C([C'] A) &= \reachability_{C'}(A)\\
\reachability_C(x) &= \emptyset \text{ otherwise }
\end{align*}
\caption{The reachability relation $\reachability_C$ computes the set
  of fields that can be derived from a grammar symbol.\label{FIG:reachability}}
\end{figure}


\def\mymultjoin{\ensuremath{\myjoin}}
\def\mymultmeet{\ensuremath{\mymeet}}
\def\mymultbottom{\ensuremath{1}}
\def\multof{\ensuremath{\mathcal{M}}}
\def\multoff{\ensuremath{\multof_f}}

\begin{figure}
\begin{align*}
\multoff(A\mid B) &= \multoff(A) \mymultjoin  \multoff(B)\\
\multoff(A\cdot B) &= \multoff(A) \mymultmeet  \multoff(B)\\
\multoff(A\;\oplus) &= \multoff(A)^\oplus \text{ where } \oplus\in \{?, *, +\}\\
\multoff(N) &= \multoff(\alpha) \text{ where } N ::= \alpha\\
\multoff(f: A) &= \multoff(A)\\
\multoff([C'] A) &= 1\\
\multoff(P\Uparrow) &= 1\\
\multoff(t) &= 1 \text{ where } t\in \{\text{\texttt{str}}, \text{\texttt{int}}, \text{\texttt{sym}}, \literal{s}, ...  \}\\
\multoff(x) &= 0 \text{ otherwise}
\end{align*}
\caption{The multiplicity relation \multoff\ computes the multiplicity
  of field occurrences in a grammar symbol.\label{FIG:multiplicity}}
\end{figure}


\def\mytypejoin{\ensuremath{\sqcup}}
%\def\mytypemeet{\ensuremath{\sqcap}}
\def\mytypebottom{\ensuremath{\bot}}
\def\mytypetop{\ensuremath{\top}}
\def\typeof{\ensuremath{\mathcal{T}}}
\def\typeoff{\ensuremath{\typeof^C_f}}
\begin{figure}
\begin{align*}
\typeoff(A\mid B) &= \typeoff(A) \mytypejoin  \typeoff(B)\\
\typeoff(A\cdot B) &= \typeoff(A) \mytypejoin  \typeoff(B)\\
\typeoff(A\;\oplus) &= \typeoff(A) \text{ where } \oplus \in \{?, *, +\}\\
\typeoff(N) &= \typeoff(\alpha) \text{ where } N ::= \alpha\\
\typeoff(f: A) &= \typeoff(A)\\
\typeoff([C'] A) &= \sigma.classes[C']\\
\typeoff(\Uparrow) &= root\\
\typeoff(/P\Uparrow) &= \text{\textsc{deref}}(root, P)\\
\typeoff(./P\Uparrow) &= \text{\textsc{deref}}(C, P)\\
\typeoff(t) &= \sigma.prims[\text{\texttt{str}}] \text{ where } t\in\{\text{\texttt{sym}}, \literal{s}, ...\}\\
\typeoff(t) &= \sigma.prims[t] \text{ where } t\in \{\text{\texttt{str}}, \text{\texttt{int}}, \text{\texttt{real}} \}\\
\typeoff(x) &= \mytypetop \text{ otherwise}
\end{align*}
\caption{The relation \typeoff computes the schema type of the field named
  $f$ in class $C$ as used in a grammar.\label{FIG:typeof}}
\end{figure}


% F, such that \bigsqcup_{i\in \mathbb{N}} F^i(S \mapsto \emptyset)


\section{Instantiating}

References: xText calls this their unique feature, and it is almost
completely the same as in Enso, even the fact that refs refer to
schema classes, not non-terminals.... However, it might provide an
interesting point for the bootstrapping, since grammar.grammar also
uses it.

No AST, but schema instance. Asynchronous transformation/binding. Case
in point (?): all binary expressions map to BinExp class, op:"+" sets
the operator literal. Other case in point: populating a collection
field, using your own recursive rule (TODO: check that it works this
way, i.e. a:X* does it append the Xs to a or set them? It should be
monotone, never overwrite anything, for collections this should mean
append). Way it works: intermediate, generic tree (also a model; the
instance tree); one visit to construct objects and populate fields,
final fixup phase for cross refs. NB: xText does it the same, but no
details, and Node tree is not a model.

\section{Modularity}

Modular: merge on both schema and grammar. Should we fully discuss
merge here? Can we modularly type check 2 grammars against 2 schemas
each, and ensure that the merged composition will type check? Abstract
rules. Modularity enabled by general parsing strategy + fixed
tokenizer (however, more keywords will be reserved).

Abstract rules. Merge. Escaping of keywords.


\section{Bootstrapping}

Bootstrapped/self-describing: initial grammar in
ruby. Grammar.grammar, grammar.schema etc. This is a major
(implementation) different with xText.

\section{Origin Tracking}

Model origin tracking: distinguish ref and reffed origin (Maybe too
much engineering issue, but possibly interesting because of merging
Location model into Instance model etc.

\section{Evaluation}

List languages used. Performance??? LOC of framework.


\section{Conclusion}






\end{document}
% Lisp reader n. Trad. the procedure that parses character representations of objects from a stream, producing objects. (This procedure is implemented by the function read.)
%http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_l.htm#lisp_reader


Typechecking: TODO. I think this would be an interesting extra
interpreter.

Debugging: could we do a simple grammar debugger by interpreter
composition? Our interpreter approach really makes debugging output
easy.

Schema inference: TODO (Do we want this? If this is really easy to
implement, we can use it to compare with xText.) Other way around:
derive a grammar from a schema.



Bi-directional: rendering/layouting. Key thing: constructor directives
become predicates, and assignments become predicates (also in @"" code
things; sequencing is conjunction). Interesting point: insertion of
required parens, with expressions.
