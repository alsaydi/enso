William: here is an example of an Enso descriptiion... of a state machine
-----------------state_machine.schema-------------------------------------
class StateMachine
  start: State
  states: State*
end

class State
  #name: str
  enter: Action
  leave: Action
  out: Transition*
  in: Transition*
end

class Transition
  event: str
  action: Action
  from: State / State.out
  to: State / State.in
end

class Action
  source: str
end

primitive str
--------------------------------------------------------------
William: its mostly self-explanatory... but the # means "key" or "primary key"... it means that the names of states are unique
William: oh.. and the "/" means "inverse relationship"
Bruno: right, I was curious about "/"
Bruno: ok; this seems quite readable
William: the inverse:   the "from" relationship of a Transition is the inverse of the "out" relationship of a State. Does that make sense?
Bruno: ok, I think it makes sense
Bruno: that's the invariant part any way, right
William: right.. the # and the / are examples of invariant, but there are more
Bruno: what does a program look like
William: Here is a grammar for state machines
-----------------state_machine.grammar-------------------------------------
Machine ::= [StateMachine] "start" \start:State^  states:State*

State ::= [State] "state" name:sym Enter? Leave? out:Transition*
Enter ::= "enter" enter:Action
Leave ::= "leave" leave:Action

Transition ::= [Transition] "on" event:str Handler? "go" to:State^
Handler ::= "do" action:Action
Action ::= [Action] source:str
----------------------------------------------------------------------
William: and an example state machine:
-----------------door.state_machine-------------------------------------
start Opened

state Opened
  on "close" go Closed
  
state Closed
  on "open" go Opened
  on "lock" go Locked

state Locked
  on "unlock" go Closed
----------------------------------------------------------------------
Bruno: aha, I see the DSLs proping up :)
William: the grammar is quite interesting... because it is so simple
William: [Foo] means "construct a foo object"
William: bar:   means "set the bar field of the current object"
William: Foo^ means "read in a *name* but replace it with what it refers too"
Bruno: you directly associate the AST to the concrete syntax
Bruno: rather than explicitly constructing the AST
William: there is no traditional AST
William: instead, the grammar creates semantic structures (the state machines) directly
William: Also, the state machine is really a graph... the links between the states are pointers, not *names*
Bruno: I see
William: Also, the grammar is bi-directional, so you use it to print state machines just as easily as parse them
Bruno: how does the evaluator look like :)?
William: Here is the interpreter!
--------------------------state_machine.rb------------------------------------
def StateMachine_Interp(sm)
  current = sm.start
  puts "#{current.name}"
  while gets
    input = $_.strip
    current.out.each do |trans|
      if trans.event == input
        current = trans.to
      end
    end
    puts "#{current.name}"
  end
end
----------------------------------------------------------------------
Bruno: ruby code?
William: yep
William: we might make an Enso code language at some point.. but for now I'm pretty happy with ruby for the actual interpreters
Bruno: right :)
William: once you deal with the data structure creation/reading/wrting/management.. the actual interpreter is fun to write
Bruno: so, enso, essentially generates the ruby code that deals with the boring parts of the DSL
William: no no no
William: no generation!
Bruno: so, what does the interpreter refers to?
Bruno: I mean: sm.start
William: its *all* interpreted... all the models (the data model and the grammar) are all interpeted
Bruno: ok
William: once you have "state_machine.schema" (the first file I sent you) and "state_machine.grammar" (the second example I sent you)
William: you can just say
William: sm = load("example.state_machine")
William: StateMachine_Interp(sm)
Bruno: I see
William: the schema (our name for a data structure description) is interpreted dynamically
William: it lets you create nodes in your graph called States and Transitions, and it lets you assess "state.name" and such (all dynamically) and it checks that all the operations are allowed by the meta-data/invariants
Bruno: ok
William: Ruby lets you say "  obj.foo"  for any "foo"
William: and it lets the object decide whether or not it wants to pretend to have a foo property
Bruno: duck typing
Bruno: :)
William: yes.. but with fairly rich types :-)
William: i think our "types" are more interesting than OO classes, and they are more interesting than haskell types
Bruno: they are certainly richer
William: our types do a lot for us.. the only thing they don't let us do is static typing
Bruno: :)
William: but... once we release Enso, the haskell people will figure out a way to do it in a few months :-)
William: you see...
William: my job...
William: is to create work for other people :-)
Bruno: Well; I am not sure if a few months :P
Bruno: graphs and meta-circularity are two of the beasts of functional programming and static types
William: right.. this might take a little while
William: yeah.. well.. i hope to keep them busy for a while
William: BTW i created the state machine example and had it running (I just typed it in earlier today as a test.. in about 10 minutes)
William: that includes a grammar and data structures and the interpreter...
Bruno: yeah, that's quite impressive. I like the way you get striaght to the point
Bruno: in enso :)
William: you could do the data and the interpreter fast in haskell.. but the grammar might take a while
William: what will be really fun.. is when I create another description for a "diagram grammar" and have a graphical editor of state machines in another 10 minutes
William: with full menus for creating new states, dragging edges, etc
Bruno: alright :) that sounds very nice :P
William: anyway... that's my goal
William: Now that you know what our schemas look like
William: are you ready for the self-describing schema-schema?
Bruno: ok
Bruno: :P
William: This schema uses one more feature, called a "computed field"
Bruno: something that depends on some other parts?
William: yes
William: its like attribute grammars... some of the data is stored, and some is computed.. but the user doesn't need to know which.  They are marked with @
-------------------schema.schema--------------------------------------------
primitive \str
  primitive \int
  primitive \bool
  primitive \real

  class Schema
    types: Type*
    classes: Class* = "@types.select(&:Class?)"
    primitives: Primitive* = "@types.select(&:Primitive?)"
  end

  class Type
    #name: str
    #\schema: Schema / Schema.types
  end

  class Primitive < Type
  end
  
  class Class < Type
    supers: Class*
    subclasses: Class* / Class.supers
    defined_fields: Field*
    fields: Field* = "@all_fields.select {|f| !f.computed}"
    all_fields: Field* = "@supers.flat_map(&:all_fields) + @defined_fields"
  end
  
  class Field
    #name: str
    #owner: Class / Class.defined_fields
    type: Type
    optional: bool
    many: bool
    key: bool
    inverse: Field? / Field.inverse 
    computed: str?
    traversal: bool
  end
----------------------------------------------------------------------  
William: This is the actual code that describes the core Enso description of structural descriptions
William: "types" is stored field
William: "classes" and "primitives" select subsets of "types" that are of two different kinds
William: oh.. this schema also uses inheritance. marked by <
Bruno: I noticed
William: the \ is used to quote names that are normally "keywords"
William: the "all_fields" field gives our complete implementation of inheritance :-)
William: it says "a classes' fields are the union of all its parents' fields, plus the fields it defines"
Bruno: right
Bruno: so, how long did it take to build your toy OO language:)?
Bruno: 30mins?
William: what do you mean?
William: oh, the stuff inside the quotes?
William: hehehe. .right now that is just Ruby code :-))))
Bruno: this description is a model for a simple OO language right?
Bruno: or is it itself the inheritance used by enso :)?
William: no.. that is a description of the structure of data structures in Enso
Bruno: uau
William: it describes the "StateMachine" structure that I showed you before
William: which had classes named "State" and "Transition" and fields named "name", "out", etc
William: it also describes itself
Bruno: uau; that's impressive metacircularity
Bruno: :P
William: right now, Enso is mostly about graphs and data... the code is all Ruby
Bruno: Let me see if I get this straight;
Bruno: this file is describing the datastructure language of enso, right?
Bruno: and you are defining this with itself?
William: yes
William: yes, it describes itself
William: (well, we should say "*a* datastructure language".. because Enso can have other kinds of data sturctures if you want them)
William: because, it is an Enso data structure :-)
Bruno: so the word "class" in this file
Bruno: is being described by
Bruno: Class
Bruno: ?
William: wait.. don't get confused between the textural representation and the semantics
Bruno: sure; I understand this
William: there is a close connection, just like there was a connection with the statemachine text and the actual in-memory state machine
Bruno: you need to give a grammar
William: right.. let me show you the grammar
-------------------------schema.grammar--------------------------------
Schema ::= [Schema] types:TypeDef* 

TypeDef ::= Primitive | Class

Primitive ::= [Primitive] "primitive" name:sym

Class ::= [Class] "class" name:sym Parent? defined_fields:Field* "end"
Parent ::= "<" supers:{Super ","}+
Super ::= Class^

Field ::= [Field] Key? Traversal? name:sym ":" type:Type Multiplicity Annot?
Key ::= "#" @"@key = true"
Traversal ::= "!" @"@traversal = true"

Type ::=  Primitive^
  | Class^

Multiplicity ::= "*" @"@many = true; @optional = true"
         | "?" @"@optional = true" 
         | "+" @"@many = true"
         | @"true"

Annot ::= "/" inverse:Field^
        | "=" computed:str
----------------------------------------------------------------------
Bruno: but, ok, this is what I meant:
Bruno: the "class" in this grammar file, is described  by Class
William: right, on the line that begins "Class".. that the word "class" is connected to the class [Class]
Bruno: this is what got me
Bruno: and this "class" keyword is the same as "class" in the previous file, right?
William: yes
William: the grammar is "the grammar of schemas" or "the grammar of data structure descriptions"
Bruno: this is amazing
Bruno: I'll have to wrap my head around this one :P
William: the one before it is "the schema of schemas" or "the structure of data structure descriptions"
William: now... a grammar is also a data structure.. .so it there is a "schema of grammars" or "description of the data structure for storing grammars"
Bruno: sure, I do understand that
William: and there is also a "grammar of grammars" because you have to be able to read and write grammars
William: :-) :-) :-)
Bruno: I am just puzzled about how to define the grammar of schemas with the grammar being defined itself
William: well. there is a bootstrapping problem
Bruno: I am sure there is :P
