Ensō notes

Since not everybody can sit in my office and brainstorm,
I'm going to try to send out summaries of the status and plans for Ensō.

The current focus is on building applications with Ensō, and creating any necessary
infrastructure to go with it. You might find it surprising that after three weeks of development
we are now aiming at building non-trivial systems in Ensō. I'm a little surprised too,
but then, it should be possible if Ensō is going to fulfill its potential.

* Ensō/Web (Tijs)
This is a web application framework.
 - has a very general template mechanism
 - all data binding is automatic
       if a form has "edit(x.name)" then saving the form will cause x.name to be updated.
       This works by assigning an *address* to every piece of data, and any field that
       is posted with an address will automatically be saved. Creation will be similar.
 - its going to need the reflective security model
 - we will need to hook it up to SQL as well

Here is a (non-running version) of a real example that Tijs got working yesterday:

def hello_world(name) {
html("Test") {
  heading( "Hello World " name )
  navigate("Hello World!", hello_world("Tijs"));
 description {
  for (x: root.classes, i) {
    item( i ": " x.name ) {
      description {
        for (y: x.fields, j) {
          item( "Field #" i ": " y.name)
}}}}

My example doesn't run I hacked it to use more library calls, and fix some syntax issues, which haven't been implemented yet. In the example, "html", "heading", and "description", and "navigate" are library calls. Description makes a list of tagged items in a list. Here are some of the library calls:

def navigate(title, page) { 
  <a href=link(page)>output(title)</a>
}

def html(title) {
<html><head><title>output(title)</title></head>
<body>yield</body>
</html>
}

Here is an sketch of a generalized template (this doesn't run yet either):

define DataTable(data, columns: column*(label, view)) {
<TABLE>
<TR>
  for c in columns do { <TD> c.label </TD> }
</TR>
  for item in data {
<TR>
    for c in column do { <TD> c.view(item) </TD> }
</TR>
  }
</TABLE>
}

This is how you would use it:

DataTable(info) {
 column("Name", edit(info.name))
 column("Size",  info.size)
}

I know that Martin is eager to create a sample application, which will
quickly drive EnsōWeb toward being real.

* Diagram Editor
The idea is to create "diagram grammars" which specify how a structure is
translated into a diagram. The grammar also controls what kind of changes
can be made to the resulting diagram, and these changes are also propagated
back to the original structure. Given this diagramming model, a diagram
grammar for schemas might look like this. The diagram parts of this are
in UPPER case, while the template/grammar parts are in lowercase.

 diagram(schema) {
    GROUP {
      -- create the nodes (one for each class)
      for (class : schema.classes) {
        NODE(class) {   -- declare the "identifier" of this node is a class
         RECTANGLE (line=3px) {  -- this is the class rectangle
           VERTICAL {
              EDIT(class.name, size=14pt)
              for (field : class.defined_fields) {
                 if (field.type.Primitive?) {
                   HORIZONTAL {
                     EDIT(field.name)  -- editable field name
                     PICK(field.type)  -- drop-down for primitive types
              -- "for" automatically creates "add/delete" buttons to edit fields
         }}}}}
        -- create the subclass edges
        for (super : class.super)
          EDGE{ FROM(class) TO(super, style=OPEN_ARROW) }
      }
      -- create the relationship edges that go between nodes
      for (class : schema.classes) {
        for (field : class.defined_fields) {
          if (!field.type.Primitive?) {
            EDGE {
              FROM(field.owner)   -- attach to node associated with owner
              TO(field.type       -- attach to node associated with type
                label=(
                  case field.many then TEXT("*")
                  case field.optional then TEXT("?"))))
         }}}}}


The plan is to be able to create a fairly complete schema editor by
just specifying a diagram grammar like the one above. All the
data binding and create/delete menus (of classes and edges) are automatic.

If you think about it, you will see that the abstract
structure of "diagram grammars" is very similar to the structure of normal
grammars, and also similar to the structure of EnsōWeb.

It should be easy to create diagram notations for grammars,
genealogy, and also for diagram grammars. That is, we will use
the diagram editor to edit diagram grammars. This kind of recursive
reuse is one of the hallmarks of Ensō, but it can also be very confusing.

I want to create this by weaving the "for/if/field" structure into the
diagram structure. Doing this requires the ability to manipulate and
generate schemas and grammars, as described in the next section.

* Diff/Merge (Alex)

The idea is to write some general combinators for manipulating structures.

Delta:  Schema -> Schema
  -- given a schema for storing Foo structures, creates a schema that can
      store *changes to Foo structures*, or "Foo deltas".

diff: S:Schema,  S,  S -> Delta(S)
  -- given a schema and two instances of the schema, return an object that
      represents the changes needed to get from the first instance to the second

apply: S:Schema, S, Delta(S) -> S
  -- given a structure and a delta structure, compute the result of applying
     the changes to the structure. It should be that
         apply(S, a, diff(S, a, b)) == b

union: S:Schema, S, S -> S
  -- a simpler function that merges two structures

To make this work we had to introduce the idea of a "traversal field". These
are fields which, taken together, are guaranteed to visit every object in a structure.
For schemas, the traversal fields are "types/defined_fields". These also happen
to be the fields that are needed for lookup of names. Traversal fields
reintroduce the idea of trees into our system. One question is whether
the traversal tree is allowed to have cycles or not. For now, I propose that we
do NOT allow cycles in the traversal tree (there can be cycles in the
traversal fields in the schema, but an actual object cannot have a cycle involving
traversal fields). This allows us to visit all objects quickly and easily. It will
also be the basis for naming/addresses in the system. Names and addresses
are a common theme, and so far Ensō has fairly good support for them.

Here is what I was thinking for Delta. I know this looks ugly,
and that worries me too. But it seems logical. I'm not sure
how to do it more simply. What it does is convert the
schema into a Delta Schema that has delta objects on the
traversal spine, and then "reference" deltas for all other fields.

Delta(schema) = Delta(t) for all t in schema.types
Delta(primitive P) =
   class DSingle$P
   class Clear$P < DSingle$P  
   class Set$P < DSingle$P
      value: $P

Delta(class C) =
   class DSingle$C
   class Clear$C < DSingle$C
   class Delta$C < DSingle$C, Delta(C') for each C' in C.supers
      for each field F in C.defined_fields
         Field(name = F.name, type=newType, optional=true, many=F.many)
      where newType = case
         when f.traversal && !f.many => DSingle$(f.type)
         when f.traversal && f.many => DMany$(f.type)
         when !f.traversal && !f.many => RefSingle
         when !f.traversal && f.many => RefMany$(f.type.key.type || int)  -- primititve type of key
   class DMany$C
      position: $(if C.key then C.key.type else int)
   class Delete$C < DMany$C
   class Insert$C < DMany$C, Delta$C
   class Modify$C < DMany$C, Delta$C

   class Ref
      position: str
   class RefSingle
   class ClearRef < SingleRef
   class SetRef < SingleRef, Ref
   class RefMany$P  -- for each primitive key type P
      position: $P
   class DeleteRef$P < RefMany$P
   class InsertRef$P < RefMany$P, Ref
   class ModifyRef$P < RefMany$P, Ref

Given the Point schema:

primitive int
class Line
  !pts: Point*
end
class Point
  x: int
  y: int
end

Applying this to Point i would give (* items are not really needed):

   *class DSingleLine
   *class ClearLine < DSingleLine
   class DeltaLine < DSingleLine
     !pts: DManyPoint

   class DManyPoint
      position: int
   class DeletePoint < DManyPoint
   class InsertPoint < DManyPoint, DeltaPoint
   class ModifyPoint < DManyPoint, DeltaPoint

   *class DSinglePoint
   *class ClearPoint < DSinglePoint
   class DeltaPoint < DSinglePoint
      x: DSingleInt?
      y: DSingleInt?

   class DSingleInt
   class ClearInt < DSingleInt
   class SetInt < DSingleInt
      value: int

This type, complex as it is, is sill not quite as precise
as it could be. In particular, Insert values don't need
to be full deltas, but could be combinations of normal
points with Ref fields in appropriate places.

(one other useful operator is Query, to select parts of a structure)

* Modularity

I want to use the union/diff operations to create new schemas and grammars
by mixing in modular schema/grammar components. This is all hypothetical
right now, but we have done a few experiments and it looks like it will work.

As a heads-up, the "start" symbol will soon be removed from grammars.
When parsing, you will have to specify the start symbol you want.

Tijs: is it possible to parse a document without knowing the start symbol?
(that is, any start symbol in the grammar will work? and you would have to
test the result type of the parsed object to see what you got)

I have some ideas about managing change within Ensō models using
Git and the loader, but its not well-formed yet.

* Executable UML

I've defined a simple state machine model. We have schemas. We need to bolt
these together, along with a simple action language, to create an Executable
UML interpreter. Then create a diagram editor for it. This is just a sample
application, but it will be a nice one.

* There are many other smaller issues in the TODO file under "doc" and also
some text and pictures in the "introduction" folder.
