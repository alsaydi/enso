I'm proposing this as actual syntax. The idea is that
we have a generic way to weave "parametization" into
a base schema, in this example it is weaved into schema schema.

Requirements


Grammars
  Special because target is a linearized format
   - must be bi-directional
  Instance facet:
   - class name as constructor/predicate
   - field names 
        relationships have arguments
              arg: Expression
        primitives currently have arguments, but they are redundant
              name: str
   - expressions as assignment/predicates
  Regular facet:
  - alternatives
  - explicit repetition with separators
  Definition facet:
  - definitions are useful, and necessary for recursion
  Syntax overall
  - custom syntax currently, no prefix character
  
General rendering
  render: All(S:Schema, T:Schema) S -> Render(T) -> T
     the Render(T) instance is gotten by loading with RenderGrammar(T)
  Only needs to be uni-directional? Diagrams could use same format,
    and they are bi-directional in a sense
  Instance facet:
   - class name as constructor/predicate
   - field names 
        relationships have arguments
              arg: Expression
        no arguments on primitives
              name
   - expressions as assignment/predicates
       must have *string interpolation*
   - need explicit label/link notation, different from existing linking model
  Regular facet:
  - alternatives
  - would be nice if repetition was implicit in the fields
      (but sometimes separators are needed?)
  Definition facet:
  - some structures have non-recursive spines, so definitions are not needed
  - each many-valued field in spine needs its own set of definition?
      (this is required so that definition body will have right type/syntax)
  - simple definitions will sometimes suffice
  - need full functions (as in EnsoWeb) in some cases
  Syntax overall
  - must have syntax that can be merged into any other language
  - configurable "prefix" character?

--------------

$for(primitives) {
  class ["DSingle"+name] end
  class ["Clear"+name] < ["DSingle"+name] end
  class ["Set"+name] < ["DSingle"+name]
    value: [name]
  end
  primitive [name]
}

$for(classes) {
   class ["DSingle"+name] end
   class ["Clear"+name] < ["DSingle"+name] end
   class ["Delta"+name] < ["DSingle"+name], $for(supers){, ["Delta"+name] }]
     $for(defined_fields) {
       [name]: [case
         when f.traversal && !f.many then "DSingle"+type.name
         when f.traversal && f.many then "DMany"+type.name
         when !f.traversal && !f.many then "RefSingle"
         when !f.traversal && f.many then "RefMany"+(type.key ? type.key.type : "int")]
       $eval{ optional=true; many=many }
     }
   end
   class ["DMany"+name]
      position: [if key then key.type.name else "int"]
   end
   class ["Delete"+name] < ["DMany"+name] end
   class ["Insert"+name] < ["DMany"+name], ["Delta"+name] end
   class ["Modify"+name] < ["DMany"+name], ["Delta"+name] end
}

   class Ref
      position: str
   end
   class RefSingle end
   class ClearRef < SingleRef end
   class SetRef < SingleRef, Ref end

$for(primitives) {
   class ["RefMany"+name]  -- for each primitive key type P
      position: "+name]
   end
   class ["DeleteRef"+name] < ["RefMany"+name] end
   class ["InsertRef"+name] < ["RefMany"+name], Ref end
   class ["ModifyRef"+name] < ["RefMany"+name], Ref end
}
--------------


-- 
William Cook
Associate Professor, Computer Science
University of Texas at Austin
