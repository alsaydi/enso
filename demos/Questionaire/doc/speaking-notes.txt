/**********************************************************
This presentation incrementally builds up the full QL DSL
and introduces the various components like binding and 
styling.
You can find the files for the various sections in this 
tarball. Either copy-paste the files or type in the diffs.

Important files:
- housing.ql (note name change)
- ql.schema
- ql.grammar
- ql.stencil
- "run-web.sh" once to start web server (note name change)
- "ruby parseToJSON.rb" after each new set of files to 
  regenerate JSON

*** = section separator
// = notes
<...> = take this action
"..."  = say this -- somewhat important
otherwise = say something 
**********************************************************/


*** Introduction ***
//intro basic structure of enso 
//go fast as there is plenty of content in demo
<run slides 1 to ..>
<slide 1, the big circle slide>
"Today I will be demonstrating Enso using the challenge
problem of LWC.
Enso is an external, mostly textual, DSL workbench.
It is implemented as a Ruby library, so all the files you
see here are text-editable.
The Enso workbench is built on top of itself as a suite of
DSLs.

<slide 2, three arrows pouring into the cauldron>



*** Basic QL (01) ***
//only questions and title
<copy files from 01-basic dir>

<show housing.ql>
"We start off with a basic QL language that only has a 
title and a list of questions. In order to define this
simple DSL, we need two things: a ql.schema and a 
ql.grammar"

<show ql.schema>
"Metamodels for Enso are written using the Schema DSL."
Classes = sets of fields
Fields = name-type pairs
- Cardinality using standard notation *, ?
- ! indicates a strong composition relationship (black
  diamond in UML)

<show ql.grammar>
Uses EBNF
- Terminal and non-terminal production rules
- Object creation tag [...] / field bindings
- Parses a text file into a model conforming to a schema

<show ql.stencil>
"Stencil is an ostensibly imperative language for 
specifying GUIs. Since a questionaire is essentially a 
projection from model to an interface, all the logic 
for this challenge is contained within this file."
- Mixture of imperative control flow structures like For 
  loops, If branches, and function calls
- With UI widgets like Text and alignment containers
  (ie vertical)

"These files are sufficient to generate a very simple 
questionaire"

<run run-web.sh>
<run parseToJSON>
<clear browser cache>
<launch web browser to localhost:8000/js/stencil.htm>
<preferably chrome>



*** Styling (02) ***
//Add styling and explain imports to structure code
"This is an extremely ugly questionaire, so let's doll
it up a little"
<open ql.stencil>
Styling can be added to widgets as CSS-like properties
<copy-paste ql.stencil from 02-styling>
"I'm going to add a background, together with separate parts
for the title and body"

<run parseToJSON>
<clear browser cache>
<launch web browser to localhost:8000/js/stencil.htm>

"Now things are starting to look unwieldy. Thankfully, 
because everything is a DSL we get to use the usual techniques
for modularity and abstraction to help us."

<copy layout.stencil and open it>
"Here we extract the styling into a function. This produces
background-title-body layout we saw just now from inputs."

<copy ql2.stencil to ql.stencil>
"And in the main ql.stencil, we import the styling function
and call it. We can also make the colors parameters if we 
want."

<re-run, but optional>

<copy ql.stencil from 02>
"For the rest of the presentation we will revert to the 
original because I don't want to work with two files."



*** Answers (03) ***
//Add answertypes and explain data bindings
"We have questions and obviously we need answers. In this
solution we specify answer types separately from the questions
so they can be shared."

<copy in ql.schema from 03-answers and open>
Questionaire contains a list of answers
- 3 types of answers
- questions have an answer type

<copy in ql.grammar from 03-answers>
<copy in housing.ql from 03-answers and open it>
Import prelude.ql include common answer types

<copy in ql.stencil from 03-answers and open it>
"In addition to printing out its text, we must also generate
the appropriate widget for answering each question."

Rules are sugared up function calls that dispatch on the 
type of the receiving object.
- body of rule can refer to receiving object
- "call draw for elem" -> draw question
- "call ans(elem.response.val) for elem.ans" -> draw ans

single and multi refer to single- and multi-select widgets
- single-select widgets can be radio buttons or dropboxes
  depending on how many choices there are.
- arrangment of multi-select (vertical or horizonal) depend
  on how wide the text is
user can also override these heuristics using styling 
properties:
eg. [type='radio'], or [arrangement='vertical']

<rerun parseToJSON>
<re-run web browser>

Data Binding:
- Implicitly bind source of value to the field
- Example: "call ans(elem.response.val)" binds the address
  of elem.response.val to the value it produces, such that
  edits in the textbox will write back to this address
(I don't know how to else to illustrate this point)



*** Computed (04) ***
"The next thing to do is to make things move. First,
we add a computed answer type."

<ql.schema from 04-computed>
"This uses the expr package from the default library so we
need to import that. The computed answer types has a 'expr'
attribute which tells us how to derive its answer."
"Now need to a way reference questions, so we give each qn
a 'name' attribute. This attribute is marked as a key for 
the question class"

<ql.grammar>
<housing.ql>
"This is what it looks like in the DSL"

<ql.stencil and open it>
"We add a new rule for computed answers. The double brackets 
say write text containing the result of evaluating the expr
on the left side of the bar, under the environment of the right
side."
"In our example, the left side will be the formula
sellingPrice.response.val - privateDebt.response.val, and the 
right side is the list of questions in the questionaire. Using
the name 'sellingPrice', we can lookup the question associated
with that label, then get the value of its response."

<run in browser>



*** Groups (05) ***
"The last thing we need to implement groups"

<ql.schema from 05-groups>
A Group can contain questions or other groups
- Groups have guards
- Form a tree of questions
- all_elems is a helper attribute to collect all questions
  with a sub-tree

<ql.grammar>
<housing.ql>
"This is what it looks like in the DSL.
Here I arbitrarily chose to enable the guard only when the value
for hasMaintLoan is greater than 1000"

<ql.stencil>
New rule for drawing a Group

Pages: container that 'stacks' up its sub-widgets.
- Index indicates which 'page' is on top
- 2 pages: vertical {...} and -- (blank page)
- index is 'evaluate this group's guard, if true, 0 else 1'

<run in browser>



*** Conclusion ***
<slide n>
- low sloc count! 
  - 84 lines total for dsl including logic
  - 14 lines for instance
  - 0 lines of 4gl code
  simplification whenever possible
- no tooling lock-in -- everything is text editable
  implementation is a single Ruby library
  "This may not be an advantage to everyone here, only the
  ones who are out to lose money"
- Everything is a language
  common concepts like modularity and reuse are ubiquitous


